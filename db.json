{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/photos/小林未郁_BECAUSE.jpg","path":"photos/小林未郁_BECAUSE.jpg","modified":1,"renderable":0},{"_id":"themes/hexo-theme-ayer/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/css/clipboard.styl","path":"css/clipboard.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/css/custom.styl","path":"css/custom.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/dist/main.css","path":"dist/main.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/ayer.png","path":"images/ayer.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/ayer.svg","path":"images/ayer.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/dist/main.js","path":"dist/main.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/ayer-side.svg","path":"images/ayer-side.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/cover7.jpg","path":"images/cover7.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/forkme.png","path":"images/forkme.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/handwriting.cur","path":"images/handwriting.cur","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/mouse.cur","path":"images/mouse.cur","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/js/busuanzi-2.3.pure.min.js","path":"js/busuanzi-2.3.pure.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/js/clickBoom1.js","path":"js/clickBoom1.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/js/clickBoom2.js","path":"js/clickBoom2.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/js/clickLove.js","path":"js/clickLove.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/js/dz.js","path":"js/dz.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/sponsor.jpg","path":"images/sponsor.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/alipay.jpg","path":"images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/cover2.jpg","path":"images/cover2.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/wechat.jpg","path":"images/wechat.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/404.jpg","path":"images/404.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/cover6.jpg","path":"images/cover6.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/cover3.jpg","path":"images/cover3.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/cover1.jpg","path":"images/cover1.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/cover4.jpg","path":"images/cover4.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-ayer/source/images/cover5.jpg","path":"images/cover5.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-ayer/.gitignore","hash":"c8339c5584cdcd73af3a1b2012763f760b7ed86b","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/.postcssrc","hash":"1dd8ddbf9ba6fd3748d0b93c1f0f3d95ec918bf0","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/.stylintrc","hash":"557d72b4dcd86e66fc5c688595288cf06b12ce6c","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/.travis.yml","hash":"c4bbefb55e020855b98b59657ef0a2816aa97add","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/LICENSE","hash":"e39066a824465f4d6ad5ce7903b4d683d38d2b6c","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/README.md","hash":"20f98e4597f29f5ad5cef3dc3ccbca57f2f87365","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/_config.yml","hash":"5873a8eff0c45a993b255c83190765fe6364e674","modified":1594953351074},{"_id":"themes/hexo-theme-ayer/logo.png","hash":"16fbb131601570b21890a922cd6e596691ccff42","modified":1594521795710},{"_id":"themes/hexo-theme-ayer/package.json","hash":"f790b903bfa4074d124c715278b8a037bd008027","modified":1594521795710},{"_id":"source/_posts/JVM-MinorGC和FullGC触发条件.md","hash":"5e9d32fdc85b666417d77e8a9b2186fee2978bef","modified":1595045138484},{"_id":"source/_posts/JVM-性能优化-Part-4-C4-垃圾回收.md","hash":"0e11cb2d08508eddec1f54e3aa019f891ca01dcb","modified":1595045057449},{"_id":"source/_posts/JVM性能检测、故障检测工具.md","hash":"dfd4cf996e3345980feb25b572f897fba4775464","modified":1595303463317},{"_id":"source/_posts/git-pull之后merging冲突解决.md","hash":"30733660ac9382896924d973988be7cee63d4878","modified":1595045085704},{"_id":"source/_posts/git博客分支管理.md","hash":"04f472382ff162760f23f800b70f9ee44a1f34eb","modified":1595045113391},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1594517959900},{"_id":"source/_posts/我的第一篇文章.md","hash":"31fc2eac0360386d5b5b5ff19228ddf1e3e1eb22","modified":1594535673421},{"_id":"source/categories/index.md","hash":"96ab2649a6ccca665f7ed9a195af20f3d4e18356","modified":1594611337076},{"_id":"source/photos/index.md","hash":"7b9cd9d0487b6e80cb358ef10e36c3512e0b3a4c","modified":1594953236353},{"_id":"source/photos/小林未郁_BECAUSE.jpg","hash":"863d0e8c74eba32d113c689e1859dd624ffe1119","modified":1594611337076},{"_id":"source/tags/index.md","hash":"d06eb05c1a72317ba5ea2282b6bb4fa4b0376f0a","modified":1594611337076},{"_id":"themes/hexo-theme-ayer/.github/FUNDING.yml","hash":"85381e9e2d3b868fb4a8a4339bcb7531690d073e","modified":1594521795707},{"_id":"themes/hexo-theme-ayer/.github/config.yml","hash":"0300d3458011582f8158a3588912dac4cb3ec21a","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/languages/de.yml","hash":"f1391e17d0422e6050171bfbc1780b4b01df4c55","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/languages/default.yml","hash":"cc74124ebfe5b673de248f6379153261b5371b43","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/languages/en.yml","hash":"cc74124ebfe5b673de248f6379153261b5371b43","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/languages/es.yml","hash":"2eaa4085a31960536bf603f0a86ea7fb58467b0a","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/languages/fr.yml","hash":"78ed4392ac0cbdc8d2b64d1d9ecba2daa31bdb8d","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/languages/ja.yml","hash":"6a77987d7f406c14d85c8a1fd20484af5a1da5c3","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/languages/ko.yml","hash":"e0b760d295cb00fe6c10e12db1d1a0b3f74f7244","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/languages/nl.yml","hash":"4ca66bec40af5fc9e06b3a1090c2c0962710ad66","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/languages/no.yml","hash":"cacdfe2df667f2b62ac425ff2fa7db7e4fdb6ec3","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/languages/pt.yml","hash":"16ac6324fd43939ff6f1264d82b90c1ce06e7912","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/languages/ru.yml","hash":"c829c571bbb14f2f523417e11d08cbcff2470e88","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/languages/vi.yml","hash":"2f31424cf9ed431a252e1dd3a3907e6a5bacbe75","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/languages/zh-CN.yml","hash":"1eb3233b86f9ac34798f9e3ad286b53e1c90f094","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/languages/zh-TW.yml","hash":"9341ba22128facea892ef91d5204db689c05bc7d","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1594521795710},{"_id":"themes/hexo-theme-ayer/layout/categories.ejs","hash":"c40f84aacdf7d33cfcb4eb9f78f331dad699abff","modified":1594521795710},{"_id":"themes/hexo-theme-ayer/layout/index.ejs","hash":"77347cbb8635611d8b1fb84bde75f9dedaf8632d","modified":1594521795710},{"_id":"themes/hexo-theme-ayer/layout/layout.ejs","hash":"070f82309fae1c1eb6afa2e331c7005654760db6","modified":1594521795710},{"_id":"themes/hexo-theme-ayer/layout/page.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1594521795710},{"_id":"themes/hexo-theme-ayer/layout/post.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1594521795710},{"_id":"themes/hexo-theme-ayer/layout/tags.ejs","hash":"88b34dd8d7b1e64fa27aa6ed72af996cf6700809","modified":1594521795710},{"_id":"themes/hexo-theme-ayer/scripts/default_config.js","hash":"70d6ee032d75410d540b6789b5949739a47f0125","modified":1594521795712},{"_id":"themes/hexo-theme-ayer/source/404.html","hash":"6f7743b6fceb16708c89cde40d66a3fa18f24a1d","modified":1594521795714},{"_id":"themes/hexo-theme-ayer/source/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1594521795714},{"_id":"themes/hexo-theme-ayer/source-src/main.js","hash":"77e753cd66579316c8c9e07e673c31ddb6e8e7f2","modified":1594521795714},{"_id":"source/_posts/git-pull之后merging冲突解决/小林未郁_BECAUSE.jpg","hash":"863d0e8c74eba32d113c689e1859dd624ffe1119","modified":1594532596343},{"_id":"themes/hexo-theme-ayer/.github/ISSUE_TEMPLATE/bug-report.md","hash":"4be6c40d386582293bcabf96321277238db57a51","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/.github/ISSUE_TEMPLATE/feature-request.md","hash":"d8d4951f5f3f08660dc4ba6d1a44eb56d3b094b4","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/.github/ISSUE_TEMPLATE/other.md","hash":"94ee4baf54bfa786228aafc0f2f8c17076a99a0b","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/.github/ISSUE_TEMPLATE/question.md","hash":"6cb78a96b83ed228fb3c956f2dbc654220335ec0","modified":1594521795708},{"_id":"themes/hexo-theme-ayer/layout/_partial/after-footer.ejs","hash":"4bdb0221990417e559a2045a1733ef3a518f7c5e","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/archive-post.ejs","hash":"9be7173badcca6582c1136204adb3aa432aada21","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/archive.ejs","hash":"a7065fad7532c5f727e8d0e18771616fea662944","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/article.ejs","hash":"af3270fd18c410c59edee95d6334665db69b018d","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/ayer.ejs","hash":"c152f7eefe949914019f875e16bc8046e4b5b253","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/footer.ejs","hash":"a8dcd61156d35cb8b270870b2e65d56c60c4dd38","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/google-analytics.ejs","hash":"5b389110f4d3b727c33c48f088a8bc7f8b577d19","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/head.ejs","hash":"26dceb25434ee7bf8f6ce01b58daafe2a482ab53","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/katex.ejs","hash":"ff2822fd2f6e8a02ce781aecf5bb031db076e882","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/mathjax.ejs","hash":"4d633c6cc375a0c81fe0ed2a114b1ac4c3cec2d9","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/modal.ejs","hash":"cf441365eff1f8143e3c9ae54954d0ebe0a358e5","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/music.ejs","hash":"cde5caf73f120b1300ec7539bbf675597688c734","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/sidebar.ejs","hash":"e3b411aef6e5f25f6c5c66b93d653ef70da8d4af","modified":1594521795710},{"_id":"themes/hexo-theme-ayer/layout/_partial/totop.ejs","hash":"43ba0cd1f9e898bcbd873b1e9a2d47249d6aaf77","modified":1594521795710},{"_id":"themes/hexo-theme-ayer/layout/_partial/viewer.ejs","hash":"6663c30882e2b375b15c147080c70d0dcce54a6f","modified":1594521795710},{"_id":"themes/hexo-theme-ayer/scripts/filters/index.js","hash":"e435b782178da75656f9616c7af564fb9ff0de50","modified":1594521795712},{"_id":"themes/hexo-theme-ayer/scripts/filters/meta_generator.js","hash":"58f4c93d22e4eb9743915223444335fb6fe06d21","modified":1594521795712},{"_id":"themes/hexo-theme-ayer/scripts/helpers/ayer-plus-vendors.js","hash":"7b3df58faaa875d17afbf74ddef5601116f2ce3d","modified":1594521795712},{"_id":"themes/hexo-theme-ayer/scripts/helpers/wordcount.js","hash":"f9c8fceb2130929b8f11e22b1c3476c99d1574a8","modified":1594521795712},{"_id":"themes/hexo-theme-ayer/scripts/lib/core.js","hash":"7908a82a86d63f35c6f785cacb1cfaf99ae7e0f9","modified":1594521795712},{"_id":"themes/hexo-theme-ayer/source/css/clipboard.styl","hash":"017f9b628806eeb199da2e77485cd9ac8e2117b3","modified":1594521795714},{"_id":"themes/hexo-theme-ayer/source/css/custom.styl","hash":"636de689fecfdda6cb4c6ce169fae2c89204f20a","modified":1594521795714},{"_id":"themes/hexo-theme-ayer/source/dist/main.css","hash":"c7ffa5ffdd1244b937fb2a384011609bcca050ce","modified":1594521795714},{"_id":"themes/hexo-theme-ayer/source/images/ayer.png","hash":"0466c05244273f645d239cd27513bfa3c50308aa","modified":1594521795716},{"_id":"themes/hexo-theme-ayer/source/images/ayer.svg","hash":"379c3307f97c364718a1dbc1e52fb14de12eb11a","modified":1594521795716},{"_id":"themes/hexo-theme-ayer/source/dist/main.js","hash":"eac86de3ed854247e50b04d6908816b1837e08cf","modified":1594521795714},{"_id":"themes/hexo-theme-ayer/source/images/ayer-side.svg","hash":"ad004ce7a873de0f91774f3d5923e010396a07bd","modified":1594521795716},{"_id":"themes/hexo-theme-ayer/source/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1594521795730},{"_id":"themes/hexo-theme-ayer/source/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1594521795730},{"_id":"themes/hexo-theme-ayer/source/images/handwriting.cur","hash":"12939a6ecd53a79c4ffb6498628fc3be6f1ec9fd","modified":1594694754091},{"_id":"themes/hexo-theme-ayer/source/images/mouse.cur","hash":"c1ffe93a6ba0d25ef06bb3d097560762e4807593","modified":1594521795730},{"_id":"themes/hexo-theme-ayer/source/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1594521795731},{"_id":"themes/hexo-theme-ayer/source/js/clickBoom1.js","hash":"56582907b4c2ece5187b8d64125f91ddabb8a24e","modified":1594521795731},{"_id":"themes/hexo-theme-ayer/source/js/clickBoom2.js","hash":"bea5232eb8b32542283d9a28257f4b85ce2f3c1b","modified":1594521795731},{"_id":"themes/hexo-theme-ayer/source/js/clickLove.js","hash":"a35dfb7ff19796c005ee30b55fd95e39d6d59a89","modified":1594521795731},{"_id":"themes/hexo-theme-ayer/source/js/dz.js","hash":"079ae73e2e396c2e00919a50a6fe0d064f99303a","modified":1594521795732},{"_id":"themes/hexo-theme-ayer/source/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1594521795732},{"_id":"themes/hexo-theme-ayer/source/js/search.js","hash":"118be0e0918532ac1225f62e1a0a6f0673e0b173","modified":1594521795732},{"_id":"themes/hexo-theme-ayer/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1594521795732},{"_id":"themes/hexo-theme-ayer/source-src/css/_darkmode.styl","hash":"ddb61f23b078101ae8ecad32972155147585eb8c","modified":1594521795712},{"_id":"themes/hexo-theme-ayer/source-src/css/_extend.styl","hash":"4980e6333c9e28408b65fcd9d89e1cddfa4508dc","modified":1594521795712},{"_id":"themes/hexo-theme-ayer/source-src/css/_mixins.styl","hash":"6959409df2dd0a1ca05be0c0e9b2a884efdfb82d","modified":1594521795712},{"_id":"themes/hexo-theme-ayer/source-src/css/_normalize.styl","hash":"630e719b9e805a26182a37152435d4787c0f1734","modified":1594521795712},{"_id":"themes/hexo-theme-ayer/source-src/css/_remixicon.styl","hash":"138284a4842820a7f2bf38c26d3d5c5b0e2219e9","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_variables.styl","hash":"910dd0682971a616e1610daec23e7ff5a556df98","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/style.styl","hash":"f9ae046355867c3e87c4aef309d1fc50aa493e0d","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/js/ayer.js","hash":"531f881d513e5be1119670db5334d3e2e6bf0194","modified":1594521795714},{"_id":"themes/hexo-theme-ayer/source-src/js/share.js","hash":"a65e4645818e4eb8d4a40d0499e1d04b6ee224bd","modified":1594521795714},{"_id":"themes/hexo-theme-ayer/source/images/sponsor.jpg","hash":"b3efa167f50cad85404c83f21dec2be570ed21dc","modified":1594521795731},{"_id":"themes/hexo-theme-ayer/screenshots/hexo-theme-ayer.png","hash":"4111670e622ce09837b6b9cc641782af75805079","modified":1594521795712},{"_id":"themes/hexo-theme-ayer/source/images/alipay.jpg","hash":"8f5409e29764fca573f1d274003910aa3c919de1","modified":1594521795716},{"_id":"themes/hexo-theme-ayer/source/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1594521795718},{"_id":"themes/hexo-theme-ayer/source/images/wechat.jpg","hash":"93a362574a8498e75dca469b7bceb0b321fda387","modified":1594521795731},{"_id":"themes/hexo-theme-ayer/source/js/jquery-2.0.3.min.js","hash":"800edb7787c30f4982bf38f2cb8f4f6fb61340e9","modified":1594521795732},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/albums.ejs","hash":"cfb16c9dda7a609776a28702e0c3854a52e422a7","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/busuanzi.ejs","hash":"4a6b6300284876a2008f2b13067d2c77cd41e26e","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/category.ejs","hash":"85f0ebeceee1c32623bfa1e4170dbe1e34442fea","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/clipboard.ejs","hash":"d6f82b35bbb060ec22c5facf0eea67cf44c396f6","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/gallery.ejs","hash":"5f8487fe7bed9a09001c6655244ff35f583cf1eb","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/gitalk.ejs","hash":"917ef5daea9c926aea4703ab3e9911c9f6d16b64","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/justifiedGallery.ejs","hash":"4a21fd3d7335ffcd0661036fee81a927c125e2e2","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/minivaline.ejs","hash":"35de54173ebae3135fc548ba8e52390fdbe585c0","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/nav.ejs","hash":"e59198918e92ef92156aeefbf6023584ac1cae64","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/search.ejs","hash":"2c9d19d1685e834aa2020998da2a2d259ce9b9ff","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/share.ejs","hash":"0a364766931f48df60b7c92fec8fde1067a93e00","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/title.ejs","hash":"3b076a65b9847cd6e0d424f5c2874046ef51d4d9","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/tocbot.ejs","hash":"9898b0dd9237e21908ba40292a8a9f947bed44d2","modified":1594521795709},{"_id":"themes/hexo-theme-ayer/source/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1594521795715},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/topping.ejs","hash":"fea793e132f627a8148059a9aee8bc33550506d1","modified":1594521795710},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/valine.ejs","hash":"bcabccb083df3d2c669c6471167de46ba3ca19c8","modified":1594521795710},{"_id":"themes/hexo-theme-ayer/layout/_partial/post/word.ejs","hash":"4b8e8455709debd73fba6bf3aad63378c4156dc1","modified":1594521795710},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/albums.styl","hash":"0659d5f7469f24a415354ff767d949926465d515","modified":1594521795712},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/apple.styl","hash":"e06dce604cc58ec39d677e4e59910c2725684901","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/archive.styl","hash":"3e61c25e6ae9a25196c6d904731cf6821c950341","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/article.styl","hash":"a8b0982dc252a2b801a6443d90a04937d4ccc1a3","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/articles.styl","hash":"39a0bc6c5cf85f0527d6ee81f6feebce8550c1dd","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/ayer.styl","hash":"da46e69f7ecc779ec137deb601c3524524fd758d","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/categories.styl","hash":"3b11d0c6c4439b0856ba81c50bd8867d5bb081da","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/float.styl","hash":"d888df89a172e4c8119cb8740fc1eae1a9539157","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/footer.styl","hash":"1a4576c38ef19834a4d0a8ac887e7b55d21f2f13","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/gallery.styl","hash":"7bdc2c9fb4971dbd7511c5cbb69bd611f20db591","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/gitalk.styl","hash":"3706eef2e0541493f1679a30241d279e29dfdc17","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/highlight.styl","hash":"e894b3a1aff76e84137e1e6db59a75afd0a53f52","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/justifiedGallery.styl","hash":"f2f43ae9831c3df017b35c68caa94f5eb911f697","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/layout.styl","hash":"b1bcdd213115c2fa8331d4e0f620dc7bcad64dc5","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/lists.styl","hash":"da8a82a48852411c10e279dfee43038d46f4f273","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/mobile.styl","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/navbar.styl","hash":"bc477e4905ab88da711e0049ac3866dd1f88f80a","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/pace.styl","hash":"bde7bf3577c66a3ac829410d52fa2144212282ef","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/reward.styl","hash":"9d06ee41617f5979fa378c6ebfacf394e58f9628","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/search.styl","hash":"f81076fc6d4a83be3371bcb79ab54d88e2605714","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/share.styl","hash":"9ce2dd3ffdc4e170dfcb975a7158f913bc40b8d8","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/sidebar.styl","hash":"600c70f1de82da5223af290d47a583f9c379d188","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/tag.styl","hash":"87df748185edfba222c3f9a4b9ef8eee0e8e5ad3","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/tocbot.styl","hash":"c5db921f8e11a7c2a340c8f1e1d93d50ade2ae1f","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source-src/css/_partial/totop.styl","hash":"9e9d8dc167ed2c332e4520cbf41244c34c1ebf64","modified":1594521795713},{"_id":"themes/hexo-theme-ayer/source/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1594521795730},{"_id":"themes/hexo-theme-ayer/source/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1594521795720},{"_id":"themes/hexo-theme-ayer/source/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1594521795718},{"_id":"themes/hexo-theme-ayer/source/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1594521795724},{"_id":"themes/hexo-theme-ayer/source/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1594521795730},{"_id":"source/_posts/git-pull之后merging冲突解决/小林未郁_BECAUSE.mp3","hash":"fb10b76313bde2191619a49574c8486e811c385d","modified":1594532033634},{"_id":"public/atom.xml","hash":"62e5d1c45c6aa28d5e1ca556bdf84535b1c7056e","modified":1595303479020},{"_id":"public/search.xml","hash":"387064600a7abfde044cd8a482aa1064c6c43d40","modified":1595303479020},{"_id":"public/categories/index.html","hash":"24308561c72888199ac8b75b2a545db4528969bb","modified":1595303479020},{"_id":"public/photos/index.html","hash":"e6bbdcd6133292c5312bc1d6883cf4d3a345ed03","modified":1595303479020},{"_id":"public/tags/index.html","hash":"c84f4900fb26acb003d7a624ceec639e6765db63","modified":1595303479020},{"_id":"public/categories/JVM/index.html","hash":"4f5153f2b8424f9768a7c27c7698a3d5970a53db","modified":1595303479020},{"_id":"public/categories/Git/index.html","hash":"704cbc89bfd363d4c1bafd30d778330d11f6a7f8","modified":1595303479020},{"_id":"public/tags/JVM/index.html","hash":"9886ad8a205e7d99533f8f03d7a27c3dde7a85d0","modified":1595303479020},{"_id":"public/tags/Git/index.html","hash":"ca68da188cec1d5c86621a69af03cd5610d1908b","modified":1595303479020},{"_id":"public/2020/07/21/JVM性能检测、故障检测工具/index.html","hash":"cd5a378934b37f0a8664b0c578736f2047ee8bd9","modified":1595303479020},{"_id":"public/2020/07/17/JVM-MinorGC和FullGC触发条件/index.html","hash":"4f51d552dfbc5a2dd920a590555e954b5c260185","modified":1595303479020},{"_id":"public/2020/07/17/JVM-性能优化-Part-4-C4-垃圾回收/index.html","hash":"79c2125274e8de85e382a445568418eff42a9df7","modified":1595303479020},{"_id":"public/2020/07/13/git博客分支管理/index.html","hash":"ff4cdff452d9875b8b91a3e1a9fcf087bd5561ab","modified":1595303479020},{"_id":"public/2020/07/12/git-pull之后merging冲突解决/index.html","hash":"cb2485e2b3f905a871d71f491608bda5c03e6194","modified":1595303479020},{"_id":"public/2020/07/12/我的第一篇文章/index.html","hash":"9b77d553e37c79f357f455607a91796358da0b9d","modified":1595303479020},{"_id":"public/2020/07/12/hello-world/index.html","hash":"8648b6e843168f9e3930ad3e2da63c2a5714a624","modified":1595303479020},{"_id":"public/archives/index.html","hash":"d197d900b094d2b014dcc7ac67f534586b99e7c1","modified":1595303479020},{"_id":"public/archives/2020/index.html","hash":"d8872e0cf17d5ba26139d91a293f5c8d18b55613","modified":1595303479020},{"_id":"public/archives/2020/07/index.html","hash":"2698dd5672bac345d696bd3fd4f8521a061ce582","modified":1595303479020},{"_id":"public/index.html","hash":"10fb8d07187b498cb76bab3018c8094766ad1d9b","modified":1595303479020},{"_id":"public/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1595303479020},{"_id":"public/images/ayer.png","hash":"0466c05244273f645d239cd27513bfa3c50308aa","modified":1595303479020},{"_id":"public/images/ayer.svg","hash":"379c3307f97c364718a1dbc1e52fb14de12eb11a","modified":1595303479020},{"_id":"public/images/ayer-side.svg","hash":"ad004ce7a873de0f91774f3d5923e010396a07bd","modified":1595303479020},{"_id":"public/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1595303479020},{"_id":"public/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1595303479020},{"_id":"public/images/handwriting.cur","hash":"12939a6ecd53a79c4ffb6498628fc3be6f1ec9fd","modified":1595303479020},{"_id":"public/images/mouse.cur","hash":"c1ffe93a6ba0d25ef06bb3d097560762e4807593","modified":1595303479020},{"_id":"public/images/sponsor.jpg","hash":"b3efa167f50cad85404c83f21dec2be570ed21dc","modified":1595303479020},{"_id":"public/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1595303479020},{"_id":"public/2020/07/12/git-pull之后merging冲突解决/小林未郁_BECAUSE.jpg","hash":"863d0e8c74eba32d113c689e1859dd624ffe1119","modified":1595303479020},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1595303479020},{"_id":"public/assets/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1595303479020},{"_id":"public/assets/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1595303479020},{"_id":"public/assets/js/Meting.min.js","hash":"a0585220b918d78649a7893279e1ec4fb5abe835","modified":1595303479020},{"_id":"public/photos/小林未郁_BECAUSE.jpg","hash":"863d0e8c74eba32d113c689e1859dd624ffe1119","modified":1595303479020},{"_id":"public/images/alipay.jpg","hash":"8f5409e29764fca573f1d274003910aa3c919de1","modified":1595303479020},{"_id":"public/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1595303479020},{"_id":"public/images/wechat.jpg","hash":"93a362574a8498e75dca469b7bceb0b321fda387","modified":1595303479020},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1595303479020},{"_id":"public/css/clipboard.css","hash":"7990b92ffeda1b06b94b50140d9c95dac21bd418","modified":1595303479020},{"_id":"public/css/custom.css","hash":"739ecc0d87742185cadc153d04271564d70cc5ac","modified":1595303479020},{"_id":"public/dist/main.js","hash":"eac86de3ed854247e50b04d6908816b1837e08cf","modified":1595303479020},{"_id":"public/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1595303479020},{"_id":"public/js/clickBoom1.js","hash":"56582907b4c2ece5187b8d64125f91ddabb8a24e","modified":1595303479020},{"_id":"public/js/clickBoom2.js","hash":"bea5232eb8b32542283d9a28257f4b85ce2f3c1b","modified":1595303479020},{"_id":"public/js/clickLove.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1595303479020},{"_id":"public/js/dz.js","hash":"079ae73e2e396c2e00919a50a6fe0d064f99303a","modified":1595303479020},{"_id":"public/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1595303479020},{"_id":"public/js/search.js","hash":"118be0e0918532ac1225f62e1a0a6f0673e0b173","modified":1595303479020},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1595303479020},{"_id":"public/404.html","hash":"b0d1a2bbfec50bec1ebaec81f1ea63d772d6136d","modified":1595303479020},{"_id":"public/dist/main.css","hash":"c7ffa5ffdd1244b937fb2a384011609bcca050ce","modified":1595303479020},{"_id":"public/js/jquery-2.0.3.min.js","hash":"800edb7787c30f4982bf38f2cb8f4f6fb61340e9","modified":1595303479020},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1595303479020},{"_id":"public/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1595303479020},{"_id":"public/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1595303479020},{"_id":"public/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1595303479020},{"_id":"public/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1595303479020},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1595303479020},{"_id":"public/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1595303479020},{"_id":"public/2020/07/12/git-pull之后merging冲突解决/小林未郁_BECAUSE.mp3","hash":"fb10b76313bde2191619a49574c8486e811c385d","modified":1595303479020}],"Category":[{"name":"JVM","_id":"ckcvei3360004ewipagqs5qt4"},{"name":"Git","_id":"ckcvei33p000jewip6tcj6mk8"}],"Data":[],"Page":[{"title":"categories","type":"categories","layout":"categories","date":"2020-07-13T02:57:50.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: \"categories\"\nlayout: \"categories\"\ndate: 2020-07-13 10:57:50\n---\n","updated":"2020-07-13T03:35:37.076Z","path":"categories/index.html","comments":1,"_id":"ckcvei3300001ewip5l3dafah","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"photos","albums":[["https://fahoud.gitee.io/hexo-dist/music/mika_Because.jpg","BECAUSE"]],"date":"2020-07-13T03:00:37.000Z","_content":"","source":"photos/index.md","raw":"---\ntitle: photos\n\nalbums: [\n\t[\"https://fahoud.gitee.io/hexo-dist/music/mika_Because.jpg\", \"BECAUSE\"]\n\t]\n\ndate: 2020-07-13 11:00:37\n---\n","updated":"2020-07-17T02:33:56.353Z","path":"photos/index.html","comments":1,"layout":"page","_id":"ckcvei3340003ewip9anp47wo","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","type":"tags","layout":"tags","date":"2020-07-13T02:59:19.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: \"tags\"\nlayout: \"tags\"\ndate: 2020-07-13 10:59:19\n---\n","updated":"2020-07-13T03:35:37.076Z","path":"tags/index.html","comments":1,"_id":"ckcvei33d0007ewip5v4sfse4","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"JVM MinorGC和FullGC触发条件","date":"2020-07-17T02:45:38.000Z","_content":"\n\n# Java垃圾回收机制\nGC，即就是Java垃圾回收机制。目前主流的JVM（HotSpot）采用的是分代收集算法。作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题。与C++不同的是，Java采用的是类似于树形结构的可达性分析法来判断对象是否还存在引用。即：从gcroot开始，把所有可以搜索得到的对象标记为存活对象。\n\n> 具体过程：\n\n当GC线程启动时，会通过可达性分析法把Eden区和From Survivor区的存活对象复制到To Survivor区，然后把Eden Space和From Survivor区的对象释放掉。当GC轮训扫描To Survivor区一定次数后，把依然存活的对象复制到老年代，然后释放To Survivor区的对象。\n\n对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，至少需要经过两次标记的过程：\n\n- 第一次标记：对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则意味可直接回收。\n\n>（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。\n\n- 第二次标记：如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列。\n\n> finalize()只能执行一次，意味着对象只能自救一次，触发下一次gc是若该对象未被标记则会直接清除\n\n# 虚拟机中GC的过程\n\n> 在初始阶段，新创建的对象被分配到Eden区，survivor的两块空间都为空。\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc1.png\" width=\"\"></div>\n\n> 当Eden区满了的时候，触发MinorGC\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc2.png\" width=\"\"></div>\n\n> 经过扫描与标记，未被标记的对象从Eden区清除，存活的对象复制或移动到From Survivor区\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc3.png\" width=\"\"></div>\n\n>  在下一次的Minor GC中，Eden区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到From survivor区。然而在From Survivor区，From Survivor的所有的数据都被复制到To Survivor，需要注意的是，在上次minor GC过程中移动到From Survivor中的两个对象在复制到To Survivor后其年龄要加1。此时Eden区From Survivor区被清空，所有存活的数据都复制到了To Survivor区，并且To Survivor区存在着年龄不一样的对象\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc4.png\" width=\"\"></div>\n\n> 再下一次MinorGC则重复这个过程，这一次survivor的两个区对换，存活的对象被复制到S0，存活的对象年龄加1，Eden区和另一个survivor区被清空\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc5.png\" width=\"\"></div>\n\n> 再经过几次Minor GC之后，当存活对象的年龄达到一个阈值之后（可通过参数配置，默认是8），就会被从年轻代Promotion到老年代\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc6.png\" width=\"\"></div>\n\n> 随着MinorGC一次又一次的进行，不断会有新的对象被promote到老年代\n\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc7.png\" width=\"\"></div>\n\n> 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc8.png\" width=\"\"></div>\n\n从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。\n\n老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动(<i>标记-整理算法</i>)，以保证内存的连续。\n\n在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。\n\n关于方法区即永久代的回收，永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：\n\n> 1. 类的所有实例都已经被回收。\n> 2. 加载类的ClassLoader已经被回收。\n> 3. 类对象的Class对象没有被引用（即没有通过反射引用该类的地方）。\n\n永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。\n\n# Minor GC ，Full GC 触发条件\n\n## Minor GC触发条件：\n> 当Eden区满时，触发Minor GC。\n\n## Full GC触发条件：\n>（1）调用System.gc时，系统建议执行Full GC，但是不必然执行  \n>（2）老年代空间不足  \n>（3）方法去空间不足  \n>（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存  \n>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。\n","source":"_posts/JVM-MinorGC和FullGC触发条件.md","raw":"---\ntitle: JVM MinorGC和FullGC触发条件\ndate: 2020-7-17 10:45:38\ntags: JVM\ncategories: JVM\n---\n\n\n# Java垃圾回收机制\nGC，即就是Java垃圾回收机制。目前主流的JVM（HotSpot）采用的是分代收集算法。作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题。与C++不同的是，Java采用的是类似于树形结构的可达性分析法来判断对象是否还存在引用。即：从gcroot开始，把所有可以搜索得到的对象标记为存活对象。\n\n> 具体过程：\n\n当GC线程启动时，会通过可达性分析法把Eden区和From Survivor区的存活对象复制到To Survivor区，然后把Eden Space和From Survivor区的对象释放掉。当GC轮训扫描To Survivor区一定次数后，把依然存活的对象复制到老年代，然后释放To Survivor区的对象。\n\n对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，至少需要经过两次标记的过程：\n\n- 第一次标记：对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则意味可直接回收。\n\n>（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。\n\n- 第二次标记：如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列。\n\n> finalize()只能执行一次，意味着对象只能自救一次，触发下一次gc是若该对象未被标记则会直接清除\n\n# 虚拟机中GC的过程\n\n> 在初始阶段，新创建的对象被分配到Eden区，survivor的两块空间都为空。\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc1.png\" width=\"\"></div>\n\n> 当Eden区满了的时候，触发MinorGC\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc2.png\" width=\"\"></div>\n\n> 经过扫描与标记，未被标记的对象从Eden区清除，存活的对象复制或移动到From Survivor区\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc3.png\" width=\"\"></div>\n\n>  在下一次的Minor GC中，Eden区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到From survivor区。然而在From Survivor区，From Survivor的所有的数据都被复制到To Survivor，需要注意的是，在上次minor GC过程中移动到From Survivor中的两个对象在复制到To Survivor后其年龄要加1。此时Eden区From Survivor区被清空，所有存活的数据都复制到了To Survivor区，并且To Survivor区存在着年龄不一样的对象\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc4.png\" width=\"\"></div>\n\n> 再下一次MinorGC则重复这个过程，这一次survivor的两个区对换，存活的对象被复制到S0，存活的对象年龄加1，Eden区和另一个survivor区被清空\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc5.png\" width=\"\"></div>\n\n> 再经过几次Minor GC之后，当存活对象的年龄达到一个阈值之后（可通过参数配置，默认是8），就会被从年轻代Promotion到老年代\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc6.png\" width=\"\"></div>\n\n> 随着MinorGC一次又一次的进行，不断会有新的对象被promote到老年代\n\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc7.png\" width=\"\"></div>\n\n> 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc8.png\" width=\"\"></div>\n\n从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。\n\n老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动(<i>标记-整理算法</i>)，以保证内存的连续。\n\n在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。\n\n关于方法区即永久代的回收，永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：\n\n> 1. 类的所有实例都已经被回收。\n> 2. 加载类的ClassLoader已经被回收。\n> 3. 类对象的Class对象没有被引用（即没有通过反射引用该类的地方）。\n\n永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。\n\n# Minor GC ，Full GC 触发条件\n\n## Minor GC触发条件：\n> 当Eden区满时，触发Minor GC。\n\n## Full GC触发条件：\n>（1）调用System.gc时，系统建议执行Full GC，但是不必然执行  \n>（2）老年代空间不足  \n>（3）方法去空间不足  \n>（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存  \n>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。\n","slug":"JVM-MinorGC和FullGC触发条件","published":1,"updated":"2020-07-18T04:05:38.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcvei32u0000ewip0huhdk2z","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"Java垃圾回收机制\"><a href=\"#Java垃圾回收机制\" class=\"headerlink\" title=\"Java垃圾回收机制\"></a>Java垃圾回收机制</h1><p>GC，即就是Java垃圾回收机制。目前主流的JVM（HotSpot）采用的是分代收集算法。作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题。与C++不同的是，Java采用的是类似于树形结构的可达性分析法来判断对象是否还存在引用。即：从gcroot开始，把所有可以搜索得到的对象标记为存活对象。</p>\n<blockquote>\n<p>具体过程：</p>\n</blockquote>\n<p>当GC线程启动时，会通过可达性分析法把Eden区和From Survivor区的存活对象复制到To Survivor区，然后把Eden Space和From Survivor区的对象释放掉。当GC轮训扫描To Survivor区一定次数后，把依然存活的对象复制到老年代，然后释放To Survivor区的对象。</p>\n<p>对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，至少需要经过两次标记的过程：</p>\n<ul>\n<li>第一次标记：对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则意味可直接回收。</li>\n</ul>\n<blockquote>\n<p>（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。</p>\n</blockquote>\n<ul>\n<li>第二次标记：如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列。</li>\n</ul>\n<blockquote>\n<p>finalize()只能执行一次，意味着对象只能自救一次，触发下一次gc是若该对象未被标记则会直接清除</p>\n</blockquote>\n<h1 id=\"虚拟机中GC的过程\"><a href=\"#虚拟机中GC的过程\" class=\"headerlink\" title=\"虚拟机中GC的过程\"></a>虚拟机中GC的过程</h1><blockquote>\n<p>在初始阶段，新创建的对象被分配到Eden区，survivor的两块空间都为空。</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc1.png\" width=\"\"></div>\n\n<blockquote>\n<p>当Eden区满了的时候，触发MinorGC</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc2.png\" width=\"\"></div>\n\n<blockquote>\n<p>经过扫描与标记，未被标记的对象从Eden区清除，存活的对象复制或移动到From Survivor区</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc3.png\" width=\"\"></div>\n\n<blockquote>\n<p> 在下一次的Minor GC中，Eden区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到From survivor区。然而在From Survivor区，From Survivor的所有的数据都被复制到To Survivor，需要注意的是，在上次minor GC过程中移动到From Survivor中的两个对象在复制到To Survivor后其年龄要加1。此时Eden区From Survivor区被清空，所有存活的数据都复制到了To Survivor区，并且To Survivor区存在着年龄不一样的对象</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc4.png\" width=\"\"></div>\n\n<blockquote>\n<p>再下一次MinorGC则重复这个过程，这一次survivor的两个区对换，存活的对象被复制到S0，存活的对象年龄加1，Eden区和另一个survivor区被清空</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc5.png\" width=\"\"></div>\n\n<blockquote>\n<p>再经过几次Minor GC之后，当存活对象的年龄达到一个阈值之后（可通过参数配置，默认是8），就会被从年轻代Promotion到老年代</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc6.png\" width=\"\"></div>\n\n<blockquote>\n<p>随着MinorGC一次又一次的进行，不断会有新的对象被promote到老年代</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc7.png\" width=\"\"></div>\n\n<blockquote>\n<p>上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc8.png\" width=\"\"></div>\n\n<p>从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。</p>\n<p>老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动(<i>标记-整理算法</i>)，以保证内存的连续。</p>\n<p>在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</p>\n<p>关于方法区即永久代的回收，永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：</p>\n<blockquote>\n<ol>\n<li>类的所有实例都已经被回收。</li>\n<li>加载类的ClassLoader已经被回收。</li>\n<li>类对象的Class对象没有被引用（即没有通过反射引用该类的地方）。</li>\n</ol>\n</blockquote>\n<p>永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。</p>\n<h1 id=\"Minor-GC-，Full-GC-触发条件\"><a href=\"#Minor-GC-，Full-GC-触发条件\" class=\"headerlink\" title=\"Minor GC ，Full GC 触发条件\"></a>Minor GC ，Full GC 触发条件</h1><h2 id=\"Minor-GC触发条件：\"><a href=\"#Minor-GC触发条件：\" class=\"headerlink\" title=\"Minor GC触发条件：\"></a>Minor GC触发条件：</h2><blockquote>\n<p>当Eden区满时，触发Minor GC。</p>\n</blockquote>\n<h2 id=\"Full-GC触发条件：\"><a href=\"#Full-GC触发条件：\" class=\"headerlink\" title=\"Full GC触发条件：\"></a>Full GC触发条件：</h2><blockquote>\n<p>（1）调用System.gc时，系统建议执行Full GC，但是不必然执行<br>（2）老年代空间不足<br>（3）方法去空间不足<br>（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存<br>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java垃圾回收机制\"><a href=\"#Java垃圾回收机制\" class=\"headerlink\" title=\"Java垃圾回收机制\"></a>Java垃圾回收机制</h1><p>GC，即就是Java垃圾回收机制。目前主流的JVM（HotSpot）采用的是分代收集算法。作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题。与C++不同的是，Java采用的是类似于树形结构的可达性分析法来判断对象是否还存在引用。即：从gcroot开始，把所有可以搜索得到的对象标记为存活对象。</p>\n<blockquote>\n<p>具体过程：</p>\n</blockquote>\n<p>当GC线程启动时，会通过可达性分析法把Eden区和From Survivor区的存活对象复制到To Survivor区，然后把Eden Space和From Survivor区的对象释放掉。当GC轮训扫描To Survivor区一定次数后，把依然存活的对象复制到老年代，然后释放To Survivor区的对象。</p>\n<p>对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，至少需要经过两次标记的过程：</p>\n<ul>\n<li>第一次标记：对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则意味可直接回收。</li>\n</ul>\n<blockquote>\n<p>（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。</p>\n</blockquote>\n<ul>\n<li>第二次标记：如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列。</li>\n</ul>\n<blockquote>\n<p>finalize()只能执行一次，意味着对象只能自救一次，触发下一次gc是若该对象未被标记则会直接清除</p>\n</blockquote>\n<h1 id=\"虚拟机中GC的过程\"><a href=\"#虚拟机中GC的过程\" class=\"headerlink\" title=\"虚拟机中GC的过程\"></a>虚拟机中GC的过程</h1><blockquote>\n<p>在初始阶段，新创建的对象被分配到Eden区，survivor的两块空间都为空。</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc1.png\" width=\"\"></div>\n\n<blockquote>\n<p>当Eden区满了的时候，触发MinorGC</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc2.png\" width=\"\"></div>\n\n<blockquote>\n<p>经过扫描与标记，未被标记的对象从Eden区清除，存活的对象复制或移动到From Survivor区</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc3.png\" width=\"\"></div>\n\n<blockquote>\n<p> 在下一次的Minor GC中，Eden区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到From survivor区。然而在From Survivor区，From Survivor的所有的数据都被复制到To Survivor，需要注意的是，在上次minor GC过程中移动到From Survivor中的两个对象在复制到To Survivor后其年龄要加1。此时Eden区From Survivor区被清空，所有存活的数据都复制到了To Survivor区，并且To Survivor区存在着年龄不一样的对象</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc4.png\" width=\"\"></div>\n\n<blockquote>\n<p>再下一次MinorGC则重复这个过程，这一次survivor的两个区对换，存活的对象被复制到S0，存活的对象年龄加1，Eden区和另一个survivor区被清空</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc5.png\" width=\"\"></div>\n\n<blockquote>\n<p>再经过几次Minor GC之后，当存活对象的年龄达到一个阈值之后（可通过参数配置，默认是8），就会被从年轻代Promotion到老年代</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc6.png\" width=\"\"></div>\n\n<blockquote>\n<p>随着MinorGC一次又一次的进行，不断会有新的对象被promote到老年代</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc7.png\" width=\"\"></div>\n\n<blockquote>\n<p>上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmgc8.png\" width=\"\"></div>\n\n<p>从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。</p>\n<p>老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动(<i>标记-整理算法</i>)，以保证内存的连续。</p>\n<p>在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</p>\n<p>关于方法区即永久代的回收，永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：</p>\n<blockquote>\n<ol>\n<li>类的所有实例都已经被回收。</li>\n<li>加载类的ClassLoader已经被回收。</li>\n<li>类对象的Class对象没有被引用（即没有通过反射引用该类的地方）。</li>\n</ol>\n</blockquote>\n<p>永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。</p>\n<h1 id=\"Minor-GC-，Full-GC-触发条件\"><a href=\"#Minor-GC-，Full-GC-触发条件\" class=\"headerlink\" title=\"Minor GC ，Full GC 触发条件\"></a>Minor GC ，Full GC 触发条件</h1><h2 id=\"Minor-GC触发条件：\"><a href=\"#Minor-GC触发条件：\" class=\"headerlink\" title=\"Minor GC触发条件：\"></a>Minor GC触发条件：</h2><blockquote>\n<p>当Eden区满时，触发Minor GC。</p>\n</blockquote>\n<h2 id=\"Full-GC触发条件：\"><a href=\"#Full-GC触发条件：\" class=\"headerlink\" title=\"Full GC触发条件：\"></a>Full GC触发条件：</h2><blockquote>\n<p>（1）调用System.gc时，系统建议执行Full GC，但是不必然执行<br>（2）老年代空间不足<br>（3）方法去空间不足<br>（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存<br>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</p>\n</blockquote>\n"},{"title":"JVM性能优化,Chapter4:C4垃圾回收","date":"2020-07-17T02:45:38.000Z","_content":"![JVMlogo](http://fahoud.gitee.io/hexo-dist/jvm/JVMlogo.jpg)\n\n# JVM 性能优化, Part 4: C4 垃圾回收\n\n> ImportNew注：本文是JVM性能优化 系列-第4篇。前3篇文章请参考文章结尾处的JVM优化系列文章。作为Eva Andreasson的JVM性能优化系列的第4篇，本文将对C4垃圾回收器进行介绍。使用C4垃圾回收器可以有效提升对低延迟有要求的企业级Java应用程序的伸缩性。\n\n到目前为止，本系列的文章将stop-the-world式的垃圾回收视为影响Java应用程序伸缩性的一大障碍，而伸缩性又是现代企业级Java应用程序开发的基础要求，因此这一问题亟待改善。幸运的是，针对此问题，JVM中已经出现了一些新特性，所使用的方式或是对stop-the-world式的垃圾回收做微调，或是消除冗长的暂停（这样更好些）。在一些多核系统中，内存不再是稀缺资源，因此，JVM的一些新特性就充分利用多核系统的潜在优势来增强Java应用程序的伸缩性。\n\n在本文中，我将着重介绍C4算法，该算法是Azul System公司中无暂停垃圾回收算法的新成果，目前只在Zing JVM上得到实现。此外，本文还将对Oracle公司的G1垃圾回收算法和IBM公司的Balanced Garbage Collection Policy算法做简单介绍。希望通过对这些垃圾回收算法的学习可以扩展你对Java内存管理模型和Java应用程序伸缩性的理解，并激发你对这方面内容的兴趣以便更深入的学习相关知识。至少，你可以学习到在选择JVM时有哪些需要关注的方面，以及在不同应用程序场景下要注意的事项。\n\n## C4算法中的并发性\n\nAzul System公司的C4（Concurrent Continuously Compacting Collector，译者注，Azul官网给出的名字是Continuously Concurrent Compacting Collector）算法使用独一无二而又非常有趣的方法来实现低延迟的分代式垃圾回收。相比于大多数分代式垃圾回收器，C4的不同之处在于它认为垃圾回收并不是什么坏事（即应用程序产生垃圾很正常），而压缩是不可避免的。在设计之初，C4就是要牺牲各种动态内存管理的需求，以满足需要长时间运行的服务器端应用程序的需求。\n\nC4算法将释放内存的过程从应用程序行为和内存分配速率中分离出来，并加以区分。这样就实现了并发运行，即应用程序可以持续运行，而不必等待垃圾回收的完成。其中的并发性是关键所在，正是由于并发性的存在才可以使暂停时间不受垃圾回收周期内堆上活动数据数量和需要跟踪与更新的引用数量的影响，将暂停时间保持在较低的水平。正如我在本系列第3篇中介绍的一样，大多数垃圾回收器在工作周期内都包含了stop-the-world式的压缩过程，这就是说应用程序的暂停时间会随活动数据总量和堆中对象间引用的复杂度的上升而增加。使用C4算法的垃圾回收器可以并发的执行压缩操作，即压缩与应用程序线程同时工作，从而解决了影响JVM伸缩性的最大难题。\n\n实际上，为了实现并发性，C4算法改变了现代Java企业级架构和部署模型的基本假设。想象一下拥有数百GB内存的JVM会是什么样的：\n\n- 部署Java应用程序时，对伸缩性的要求无需要多个JVM配合，在单一JVM实例中即可完成。这时的部署是什么样呢？\n\n- 有哪些以往因GC限制而无法在内存存储的对象？\n\n- 那些分布式集群（如缓存服务器、区域服务器，或其他类型的服务器节点）会有什么变化？当可以增加JVM内存而不会对应用程序响应时间造成负面影响时，传统的节点数量、节点死亡和缓存丢失的计算会有什么变化呢？\n\n## C4算法的3的阶段\n\nC4算法的一个基本假设是“垃圾回收不是坏事”和“压缩不可避免”。C4算法的设计目标是实现垃圾回收的并发与协作，剔除stop-the-world式的垃圾回收。C4垃圾回收算法包含一下3个阶段：\n\n> 1. <i>标记（Marking）</i> — 找到活动对象\n\n> 2. <i>重定位（Relocation）</i> — 将存活对象移动到一起，以便可以释放较大的连续空间，这个阶段也可称为“压缩（compaction）”\n\n> 3. <i>重映射（Remapping）</i> — 更新被移动的对象的引用。\n\n下面的内容将对每个阶段做详细介绍。\n\n## C4算法中的标记阶段\n\n在C4算法中，<i>标记阶段（marking phase）</i>使用了<i>并发标记（concurrent marking）</i>和<i>引用跟踪（reference-tracing）</i>的方法来标记活动对象，这方面内容已经在本系列的第3篇中介绍过。\n\n在标记阶段中，GC线程会从线程栈和寄存器中的活动对象开始，遍历所有的引用，标记找到的对象，这些GC线程会遍历堆上所有的<i>可达（reachable）</i>对象。在这个阶段，C4算法与其他并发标记器的工作方式非常相似。\n\nC4算法的标记器与其他并发标记器的区别也是始于并发标记阶段的。在并发标记阶段中，如果应用程序线程修改未标记的对象，那么该对象会被放到一个队列中，以备遍历。这就保证了该对象最终会被标记，也因为如此，C4垃圾回收器或另一个应用程序线程不会重复遍历该对象。这样就节省了标记时间，消除了<i>递归重标记（recursive remark）</i>的风险。（注意，长时间的递归重标记有可能会使应用程序因无法获得足够的内存而抛出<b>OOM错误</b>，这也是大部分垃圾回收场景中的普遍问题。）\n\n![Figure 1](http://fahoud.gitee.io/hexo-dist/jvm/jvmperf4.png)\n<center style=\"font-size:14px;color:#444043;text-decoration:none\">Figure 1. Application threads traverse the heap just once during marking</center>\n\n\n如果C4算法的实现是基于<i>脏卡表（dirty-card tables）</i>或其他对已经遍历过的堆区域的读写操作进行记录的方法，那垃圾回收线程就需要重新访问这些区域做重标记。在极端条件下，垃圾回收线程会陷入到永无止境的重标记中 —— 至少这个过程可能会长到使应用程序因无法分配到新的内存而抛出OOM错误。但C4算法是基于LVB（load value barrier）实现的，LVB具有自愈能力，可以使应用程序线程迅速查明某个引用是否已经被标记过了。如果这个引用没有被标记过，那么应用程序会将其添加到GC队列中。一旦该引用被放入到队列中，它就不会再被重标记了。应用程序线程可以继续做它自己的事。\n\n> <i>脏对象（dirty object）和卡表（card table）</i>\n\n由于某些原因（例如在一个并发垃圾回收周期中，对象被修改了），垃圾回收器需要重新访问某些对象，那么这些对象脏对象（dirty object）。这这些脏对象，或堆中脏区域的引用，通过会记录在一个专门的数据结构中，这就是卡表。\n\n在C4算法中，并没有<i>重标记（re-marking）</i>这个阶段，在第一次便利整个堆时就会将所有可达对象做标记。因为运行时不需要做重标记，也就不会陷入无限循环的重标记陷阱中，由此而降低了应用程序因无法分配到内存而抛出OOM错误的风险。\n\n## C4算法中的重定位 ——　应用程序线程与GC的协作\n\nC4算法中，<i>重定位阶段（reloacation phase）</i>是由GC线程和应用程序线程以协作的方式，并发完成的。这是因为GC线程和应用程序线程会同时工作，而且无论哪个线程先访问将被移动的对象，都会以协作的方式帮助完成该对象的移动任务。因此，应用程序线程可以继续执行自己的任务，而不必等待整个垃圾回收周期的完成。\n\n正如Figure 2所示，碎片内存页中的活动对象会被重定位。在这个例子中，应用程序线程先访问了要被移动的对象，那么应用程序线程也会帮助完成移动该对象的工作的初始部分，这样，它就可以很快的继续做自己的任务。虚拟地址（指相关引用）可以指向新的正确位置，内存也可以快速回收。\n\n\n![Figure 2](http://fahoud.gitee.io/hexo-dist/jvm/jvmperf5.png)\n<center style=\"font-size:14px;color:#444043;text-decoration:none\">Figure 2. A page selected for relocation and the empty new page that it will be moved to</center>\n\n\n如果是GC线程先访问到了将被移动的对象，那事情就简单多了，GC线程会执行移动操作的。如果在<i>重映射阶段（re-mapping phase，后续会提到）</i>也访问这个对象，那么它必须检查该对象是否是要被移动的。如果是，那么应用程序线程会重新定位这个对象的位置，以便可以继续完成自己任务。（对大对象的移动是通过将该对象打碎再移动完成的。如果你对这部分内容感兴趣的话，推荐你阅读一下相关资源中的这篇白皮书“C4: The Continuously Concurrent Compacting Collector”）\n\n当所有的活动对象都从某个内存也中移出后，剩下的就都是垃圾数据了，这个内存页也就可以被整体回收了。正如Figure 2中所示。\n\n> 关于清理\n\n在C4算法中并没有清理阶段（sweep phase），因此也就不需要这个在大多数垃圾回收算法中比较常用的操作。在指向被移动的对象的引用都更新为指向新的位置之前，from页中的虚拟地址空间必须被完整保留。所以C4算法的实现保证了，在所有指向这个页的引用处于稳定状态前，所有的虚拟地址空间都会被锁定。然后，算法会立即回收物理内存页。\n\n很明显，无需执行stop-the-world式的移动对象是有很大好处的。由于在重定位阶段，所有活动对象都是并发移动的，因此它们可以被更有效率的放入到相邻的地址中，并且可以充分的压缩。通过并发执行重定位操作，堆被压缩为连续空间，也无需挂起所有的应用程序线程。这种方式消除了Java应用程序访问内存的传统限制（更多关于Java应用程序内存模型的内容参见ImportNew编译整理的第一篇《[JVM性能优化， Part 1 ―― JVM简介](http://www.importnew.com/1774.html)》）。\n\n经过上述的过程后，如何更新引用呢？如何实现一个非stop-the-world式的操作呢？\n\n## C4算法中的重映射\n\n在重定位阶段，某些指向被移动的对象的引用会自动更新。但是，在重定位阶段，那些指向了被移动的对象的引用并没有更新，仍然指向原处，所以它们需要在后续完成更新操作。C4算法中的重映射阶段（re-mapping phase）负责完成对那些活动对象已经移出，但仍指向那些的引用进行更新。当然，重映射也是一个协作式的并发操作。\n\nFigure 3中，在重定位阶段，活动对象已经被移动到了一个新的内存页中。在重定位之后，GC线程立即开始更新那些仍然指向之前的虚拟地址空间的引用，将它们指向那些被移动的对象的新地址。垃圾回收器会一直执行此项任务，直到所有的引用都被更新，这样原先虚拟内存空间就可以被整体回收了。\n\n\n![Figure 3](http://fahoud.gitee.io/hexo-dist/jvm/jvmperf6.png)\n<center style=\"font-size:14px;color:#444043;text-decoration:none\">Figure 3. Whatever thread finds an invalid address enables an update to the correct new address</center>\n\n\n但如果在GC完成对所有引用的更新之前，应用程序线程想要访问这些引用的话，会出现什么情况呢？在C4算法中，应用程序线程可以很方便的帮助完成对引用进行更新的工作。如果在重映射阶段，应用程序线程访问了处于非稳定状态的引用，它会找到该引用的正确指向。如果应用程序线程找到了正确的引用，它会更新该引用的指向。当完成更新后，应用程序线程会继续自己的工作。\n\n协作式的重映射保证了引用只会被更新一次，该引用下的子引用也都可以指向正确的新地址。此外，在大多数其他GC实现中，引用指向的地址不会被存储在该对象被移动之前的位置；相反，这些地址被存储在一个堆外结构（off-heap structure）中。这样，无需在对所有引用的更新完成之前，再花费精力保持整个内存页完好无损，这个内存页可以被整体回收。\n\n## C4算法真的是无暂停的么？\n\n在C4算法的重映射阶段，正在跟踪引用的线程仅会被中断一次，而这次中断仅仅会持续到对该引用的检索和更新完成，在这次中断后，线程会继续运行。相比于其他并发算法来说，这种实现会带来巨大的性能提升，因为其他的并发立即回收算法需要等到每个线程都运行到一个<i>安全点（safe point）</i>，然后同时挂起所有线程，再开始对所有的引用进行更新，完成后再恢复所有线程的运行。\n\n对于并发压缩垃圾回收器来说，由于垃圾回收所引起的暂停从来都不是问题。在C4算法的重定位阶段中，也不会有再出现更糟的碎片化场景了。实现了C4算法的垃圾回收器也不会出现背靠背（back-to-back）式的垃圾回收周期，或者是因垃圾回收而使应用程序暂停数秒甚至数分钟。如果你曾经体验过这种stop-the-world式的垃圾回收，那么很有可能是你给应用程序设置的内存太小了。你可以试用一下实现了C4算法的垃圾回收器，并为其分配足够多的内存，而完全不必担心暂停时间过长的问题。\n\n## 评估C4算法和其他可选方案\n\n像往常一样，你需要针对应用程序的需求选择一款JVM和垃圾回收器。C4算法在设计之初就是无论堆中活动数据有多少，只要应用程序还有足够的内存可用，暂停时间都始终保持在较低的水平。正因如此，对于那些有大量内存可用，而对响应时间比较敏感的应用程来说，选择实现了C4算法的垃圾回收器正是不二之选。\n\n而对于那些要求快速启动，内存有限的客户端应用程序来说，C4就不是那么适用。而对于那些对吞吐量有较高要求的应用程序来说，C4也并不适用。真正能够发挥C4威力的是那些为了提升应用程序工作负载而在每台服务器上部署了4到16个JVM实例的场景。此外，如果你经常要对垃圾回收器做调优的话，那么不妨考虑一下使用C4算法。综上所述，当响应时间比吞吐量占有更高的优先级时，C4是个不错的选择。而对那些不能接受长时间暂停的应用程序来说，C4是个理想的选择。\n\n如果你正考虑在生产环境中使用C4，那么你可能还需要重新考虑一下如何部署应用程序。例如，不必为每个服务器配置16个具有2GB堆的JVM实例，而是使用一个64GB的JVM实例（或者增加一个作为热备份）。C4需要尽可能大的内存来保证始终有一个空闲内存页来为新创建的对象分配内存。（记住，内存不再是昂贵的资源了！）\n\n如果你没有64GB，128GB，或1TB（或更多）内存可用，那么分布式的多JVM部署可能是一个更好的选择。在这种场景中，你可以考虑使用Oracle HotSpot JVM的G1垃圾回收器，或者IBM JVM的平衡垃圾回收策略（Balanced Garbage Collection Policy）。下面将对这两种垃圾回收器做简单介绍。\n\n## Gargabe-First （G1） 垃圾回收器\n\nG1垃圾回收器是新近才出现的垃圾回收器，是Oracle HotSpot JVM的一部分，在最近的JDK1.6版本中首次出现（译者注，该文章写于2012-07-11）。在启动Oracle JDK时附加命令行选项-XX:+UseG1GC，可以启动G1垃圾回收器。\n\n与C4类似，这款标记-清理（mark-and-sweep）垃圾回收器也可作为对低延迟有要求的应用程序的备选方案。G1算法将堆分为固定大小区域，垃圾回收会作用于其中的某些区域。在应用程序线程运行的同时，启用后台线程，并发的完成标记工作。这点与其他并发标记算法相似。\n\nG1增量方法可以使暂停时间更短，但更频繁，而这对一些力求避免长时间暂停的应用程序来说已经足够了。另一方面，正如在本系列的[Part 3][4]中介绍的，使用G1垃圾回收器需要针对应用程序的实际需求做长时间的调优，而其GC中断又是stop-the-world式的。所以对那些对低延迟有很高要求的应用程序来说，G1并不是一个好的选择。进一步说，从暂停时间总长来看，G1长于CMS（Oracle JVM中广为人知的并发垃圾回收器）。\n\nG1使用拷贝算法（在Part 3中介绍过）完成部分垃圾回收任务。这样，每次垃圾回收器后，都会产生完全可用的空闲空间。G1垃圾回收器定义了一些区域的集合作为年轻代，剩下的作为老年代。\n\nG1已经吸引了足够多的注意，引起了不小的轰动，但是它真正的挑战在于如何应对现实世界的需求。正确的调优就是其中一个挑战 —— 回忆一下，对于动态应用程序负载来说，没有永远“正确的调优”。一个问题是如何处理与分区大小相近的大对象，因为剩余的空间会成为碎片而无法使用。还有一个性能问题始终困扰着低延迟垃圾回收器，那就是垃圾回收器必须管理额外的数据结构。就我来说，使用G1的关键问题在于如何解决stop-the-world式垃圾回收器引起的暂停。Stop-the-world式的垃圾回收引起的暂停使任何垃圾回收器的能力都受制于堆大小和活动数据数量的增长，对企业级Java应用程序的伸缩性来说是一大困扰。\n\n## IBM JVM的平衡垃圾回收策略（Balanced Garbage Collection Policy）\n\nIBM JVM的平衡垃圾回收（Balanced Garbage Collection BGC）策略通过在启动IBM JDK时指定命令行选项-Xgcpolicy:balanced来启用。乍一看，BGC很像G1，它也是将Java堆划分成相同大小的空间，称为区间（region），执行垃圾回收时会对每个区间单独回收。为了达到最佳性能，在选择要执行垃圾回收的区间时使用了一些启发性算法。BGC中关于代的划分也与G1相似。\n\nIBM的平衡垃圾回收策略仅在64位平台得到实现，是一种NUMA架构（Non-Uniform Memory Architecture），设计之初是为了用于具有4GB以上堆的应用程序。由于拷贝算法或压缩算法的需要，BGC的部分垃圾回收工作是stop-the-world式的，并非完全并发完成。所以，归根结底，BGC也会遇到与G1和其他没有实现并发压缩选法的垃圾回收器相似的问题。\n\n### 结论：回顾\n\nC4是基于引用跟踪的、分代式的、并发的、协作式垃圾回收算法，目前只在Azul System公司的Zing JVM得到实现。C4算法的真正价值在于：\n\n> 消除了重标记可能引起的重标记无限循环，也就消除了在标记阶段出现OOM错误的风险。\n\n> 压缩，以自动、且不断重定位的方式消除了固有限制：堆中活动数据越多，压缩所引起的暂停越长。\n\n> 垃圾回收不再是stop-the-world式的，大大降低垃圾回收对应用程序响应时间造成的影响。\n\n> 没有了清理阶段，降低了在完成GC之前就因为空闲内存不足而出现OOM错误的风险。\n\n> 内存可以以页为单位立即回收，使那些需要使用较多内存的Java应用程序有足够的内存可用。\n\n并发压缩是C4独一无二的优势。使应用程序线程GC线程协作运行，保证了应用程序不会因GC而被阻塞。C4将内存分配和提供足够连续空闲内存的能力完全区分开。C4使你可以为JVM实例分配尽可能大的内存，而无需为应用程序暂停而烦恼。使用得当的话，这将是JVM技术的一项革新，它可以借助于当今的多核、TB级内存的硬件优势，大大提升低延迟Java应用程序的运行速度。\n\n如果你不介意一遍又一遍的调优，以及频繁的重启的话，如果你的应用程序适用于水平部署模型的话（即部署几百个小堆JVM实例而不是几个大堆JVM实例），G1也是个不错的选择。\n\n对于<i>动态低延迟启发性自适应（dynamic low-latency heuristic adaption）</i>算法而言，BGC是一项革新，JVM研究者对此算法已经研究了几十年。该算法可以应用于较大的堆。而<i>动态自调优算法（ dynamic self-tuning algorithm）</i>的缺陷是，它无法跟上突然出现的负载高峰。那时，你将不得不面对最糟糕的场景，并根据实际情况再分配相关资源。\n\n最后，为你的应用程序选择最适合的JVM和垃圾回收器时，最重要的考虑因素是应用程序中吞吐量和暂停时间的优先级次序。你想把时间和金钱花在哪？从纯粹的技术角度说，基于我十年来对垃圾回收的经验，我一直在寻找更多关于并发压缩的革新性技术，或其他可以以较小代价完成移动对象或重定位的方法。我想影响企业级Java应用程序伸缩性的关键就在于并发性。\n\n<b>JVM 性能优化系列\n\n第一篇 《[JVM性能优化， Part 1 ―― JVM简介](http://www.importnew.com/1774.html) 》\n\n第二篇《[JVM性能优化， Part 2 ―― 编译器](http://www.importnew.com/2009.html)》\n\n第三篇《[JVM性能优化， Part 3 —— 垃圾回收](http://www.importnew.com/2233.html)》</b>\n\n \n\n<i>原文链接： [javaworld](https://www.infoworld.com/article/2078661/jvm-performance-optimization--part-4--c4-garbage-collection-for-low-latency-java-ap.html) 翻译： [ImportNew.com](www.importnew.com) - [曹旭东](http://www.importnew.com/author/caoxudong)\n译文链接： http://www.importnew.com/2410.html</i>\n","source":"_posts/JVM-性能优化-Part-4-C4-垃圾回收.md","raw":"---\ntitle: JVM性能优化,Chapter4:C4垃圾回收\ndate: 2020-7-17 10:45:38\ntags: JVM\ncategories: JVM\n---\n![JVMlogo](http://fahoud.gitee.io/hexo-dist/jvm/JVMlogo.jpg)\n\n# JVM 性能优化, Part 4: C4 垃圾回收\n\n> ImportNew注：本文是JVM性能优化 系列-第4篇。前3篇文章请参考文章结尾处的JVM优化系列文章。作为Eva Andreasson的JVM性能优化系列的第4篇，本文将对C4垃圾回收器进行介绍。使用C4垃圾回收器可以有效提升对低延迟有要求的企业级Java应用程序的伸缩性。\n\n到目前为止，本系列的文章将stop-the-world式的垃圾回收视为影响Java应用程序伸缩性的一大障碍，而伸缩性又是现代企业级Java应用程序开发的基础要求，因此这一问题亟待改善。幸运的是，针对此问题，JVM中已经出现了一些新特性，所使用的方式或是对stop-the-world式的垃圾回收做微调，或是消除冗长的暂停（这样更好些）。在一些多核系统中，内存不再是稀缺资源，因此，JVM的一些新特性就充分利用多核系统的潜在优势来增强Java应用程序的伸缩性。\n\n在本文中，我将着重介绍C4算法，该算法是Azul System公司中无暂停垃圾回收算法的新成果，目前只在Zing JVM上得到实现。此外，本文还将对Oracle公司的G1垃圾回收算法和IBM公司的Balanced Garbage Collection Policy算法做简单介绍。希望通过对这些垃圾回收算法的学习可以扩展你对Java内存管理模型和Java应用程序伸缩性的理解，并激发你对这方面内容的兴趣以便更深入的学习相关知识。至少，你可以学习到在选择JVM时有哪些需要关注的方面，以及在不同应用程序场景下要注意的事项。\n\n## C4算法中的并发性\n\nAzul System公司的C4（Concurrent Continuously Compacting Collector，译者注，Azul官网给出的名字是Continuously Concurrent Compacting Collector）算法使用独一无二而又非常有趣的方法来实现低延迟的分代式垃圾回收。相比于大多数分代式垃圾回收器，C4的不同之处在于它认为垃圾回收并不是什么坏事（即应用程序产生垃圾很正常），而压缩是不可避免的。在设计之初，C4就是要牺牲各种动态内存管理的需求，以满足需要长时间运行的服务器端应用程序的需求。\n\nC4算法将释放内存的过程从应用程序行为和内存分配速率中分离出来，并加以区分。这样就实现了并发运行，即应用程序可以持续运行，而不必等待垃圾回收的完成。其中的并发性是关键所在，正是由于并发性的存在才可以使暂停时间不受垃圾回收周期内堆上活动数据数量和需要跟踪与更新的引用数量的影响，将暂停时间保持在较低的水平。正如我在本系列第3篇中介绍的一样，大多数垃圾回收器在工作周期内都包含了stop-the-world式的压缩过程，这就是说应用程序的暂停时间会随活动数据总量和堆中对象间引用的复杂度的上升而增加。使用C4算法的垃圾回收器可以并发的执行压缩操作，即压缩与应用程序线程同时工作，从而解决了影响JVM伸缩性的最大难题。\n\n实际上，为了实现并发性，C4算法改变了现代Java企业级架构和部署模型的基本假设。想象一下拥有数百GB内存的JVM会是什么样的：\n\n- 部署Java应用程序时，对伸缩性的要求无需要多个JVM配合，在单一JVM实例中即可完成。这时的部署是什么样呢？\n\n- 有哪些以往因GC限制而无法在内存存储的对象？\n\n- 那些分布式集群（如缓存服务器、区域服务器，或其他类型的服务器节点）会有什么变化？当可以增加JVM内存而不会对应用程序响应时间造成负面影响时，传统的节点数量、节点死亡和缓存丢失的计算会有什么变化呢？\n\n## C4算法的3的阶段\n\nC4算法的一个基本假设是“垃圾回收不是坏事”和“压缩不可避免”。C4算法的设计目标是实现垃圾回收的并发与协作，剔除stop-the-world式的垃圾回收。C4垃圾回收算法包含一下3个阶段：\n\n> 1. <i>标记（Marking）</i> — 找到活动对象\n\n> 2. <i>重定位（Relocation）</i> — 将存活对象移动到一起，以便可以释放较大的连续空间，这个阶段也可称为“压缩（compaction）”\n\n> 3. <i>重映射（Remapping）</i> — 更新被移动的对象的引用。\n\n下面的内容将对每个阶段做详细介绍。\n\n## C4算法中的标记阶段\n\n在C4算法中，<i>标记阶段（marking phase）</i>使用了<i>并发标记（concurrent marking）</i>和<i>引用跟踪（reference-tracing）</i>的方法来标记活动对象，这方面内容已经在本系列的第3篇中介绍过。\n\n在标记阶段中，GC线程会从线程栈和寄存器中的活动对象开始，遍历所有的引用，标记找到的对象，这些GC线程会遍历堆上所有的<i>可达（reachable）</i>对象。在这个阶段，C4算法与其他并发标记器的工作方式非常相似。\n\nC4算法的标记器与其他并发标记器的区别也是始于并发标记阶段的。在并发标记阶段中，如果应用程序线程修改未标记的对象，那么该对象会被放到一个队列中，以备遍历。这就保证了该对象最终会被标记，也因为如此，C4垃圾回收器或另一个应用程序线程不会重复遍历该对象。这样就节省了标记时间，消除了<i>递归重标记（recursive remark）</i>的风险。（注意，长时间的递归重标记有可能会使应用程序因无法获得足够的内存而抛出<b>OOM错误</b>，这也是大部分垃圾回收场景中的普遍问题。）\n\n![Figure 1](http://fahoud.gitee.io/hexo-dist/jvm/jvmperf4.png)\n<center style=\"font-size:14px;color:#444043;text-decoration:none\">Figure 1. Application threads traverse the heap just once during marking</center>\n\n\n如果C4算法的实现是基于<i>脏卡表（dirty-card tables）</i>或其他对已经遍历过的堆区域的读写操作进行记录的方法，那垃圾回收线程就需要重新访问这些区域做重标记。在极端条件下，垃圾回收线程会陷入到永无止境的重标记中 —— 至少这个过程可能会长到使应用程序因无法分配到新的内存而抛出OOM错误。但C4算法是基于LVB（load value barrier）实现的，LVB具有自愈能力，可以使应用程序线程迅速查明某个引用是否已经被标记过了。如果这个引用没有被标记过，那么应用程序会将其添加到GC队列中。一旦该引用被放入到队列中，它就不会再被重标记了。应用程序线程可以继续做它自己的事。\n\n> <i>脏对象（dirty object）和卡表（card table）</i>\n\n由于某些原因（例如在一个并发垃圾回收周期中，对象被修改了），垃圾回收器需要重新访问某些对象，那么这些对象脏对象（dirty object）。这这些脏对象，或堆中脏区域的引用，通过会记录在一个专门的数据结构中，这就是卡表。\n\n在C4算法中，并没有<i>重标记（re-marking）</i>这个阶段，在第一次便利整个堆时就会将所有可达对象做标记。因为运行时不需要做重标记，也就不会陷入无限循环的重标记陷阱中，由此而降低了应用程序因无法分配到内存而抛出OOM错误的风险。\n\n## C4算法中的重定位 ——　应用程序线程与GC的协作\n\nC4算法中，<i>重定位阶段（reloacation phase）</i>是由GC线程和应用程序线程以协作的方式，并发完成的。这是因为GC线程和应用程序线程会同时工作，而且无论哪个线程先访问将被移动的对象，都会以协作的方式帮助完成该对象的移动任务。因此，应用程序线程可以继续执行自己的任务，而不必等待整个垃圾回收周期的完成。\n\n正如Figure 2所示，碎片内存页中的活动对象会被重定位。在这个例子中，应用程序线程先访问了要被移动的对象，那么应用程序线程也会帮助完成移动该对象的工作的初始部分，这样，它就可以很快的继续做自己的任务。虚拟地址（指相关引用）可以指向新的正确位置，内存也可以快速回收。\n\n\n![Figure 2](http://fahoud.gitee.io/hexo-dist/jvm/jvmperf5.png)\n<center style=\"font-size:14px;color:#444043;text-decoration:none\">Figure 2. A page selected for relocation and the empty new page that it will be moved to</center>\n\n\n如果是GC线程先访问到了将被移动的对象，那事情就简单多了，GC线程会执行移动操作的。如果在<i>重映射阶段（re-mapping phase，后续会提到）</i>也访问这个对象，那么它必须检查该对象是否是要被移动的。如果是，那么应用程序线程会重新定位这个对象的位置，以便可以继续完成自己任务。（对大对象的移动是通过将该对象打碎再移动完成的。如果你对这部分内容感兴趣的话，推荐你阅读一下相关资源中的这篇白皮书“C4: The Continuously Concurrent Compacting Collector”）\n\n当所有的活动对象都从某个内存也中移出后，剩下的就都是垃圾数据了，这个内存页也就可以被整体回收了。正如Figure 2中所示。\n\n> 关于清理\n\n在C4算法中并没有清理阶段（sweep phase），因此也就不需要这个在大多数垃圾回收算法中比较常用的操作。在指向被移动的对象的引用都更新为指向新的位置之前，from页中的虚拟地址空间必须被完整保留。所以C4算法的实现保证了，在所有指向这个页的引用处于稳定状态前，所有的虚拟地址空间都会被锁定。然后，算法会立即回收物理内存页。\n\n很明显，无需执行stop-the-world式的移动对象是有很大好处的。由于在重定位阶段，所有活动对象都是并发移动的，因此它们可以被更有效率的放入到相邻的地址中，并且可以充分的压缩。通过并发执行重定位操作，堆被压缩为连续空间，也无需挂起所有的应用程序线程。这种方式消除了Java应用程序访问内存的传统限制（更多关于Java应用程序内存模型的内容参见ImportNew编译整理的第一篇《[JVM性能优化， Part 1 ―― JVM简介](http://www.importnew.com/1774.html)》）。\n\n经过上述的过程后，如何更新引用呢？如何实现一个非stop-the-world式的操作呢？\n\n## C4算法中的重映射\n\n在重定位阶段，某些指向被移动的对象的引用会自动更新。但是，在重定位阶段，那些指向了被移动的对象的引用并没有更新，仍然指向原处，所以它们需要在后续完成更新操作。C4算法中的重映射阶段（re-mapping phase）负责完成对那些活动对象已经移出，但仍指向那些的引用进行更新。当然，重映射也是一个协作式的并发操作。\n\nFigure 3中，在重定位阶段，活动对象已经被移动到了一个新的内存页中。在重定位之后，GC线程立即开始更新那些仍然指向之前的虚拟地址空间的引用，将它们指向那些被移动的对象的新地址。垃圾回收器会一直执行此项任务，直到所有的引用都被更新，这样原先虚拟内存空间就可以被整体回收了。\n\n\n![Figure 3](http://fahoud.gitee.io/hexo-dist/jvm/jvmperf6.png)\n<center style=\"font-size:14px;color:#444043;text-decoration:none\">Figure 3. Whatever thread finds an invalid address enables an update to the correct new address</center>\n\n\n但如果在GC完成对所有引用的更新之前，应用程序线程想要访问这些引用的话，会出现什么情况呢？在C4算法中，应用程序线程可以很方便的帮助完成对引用进行更新的工作。如果在重映射阶段，应用程序线程访问了处于非稳定状态的引用，它会找到该引用的正确指向。如果应用程序线程找到了正确的引用，它会更新该引用的指向。当完成更新后，应用程序线程会继续自己的工作。\n\n协作式的重映射保证了引用只会被更新一次，该引用下的子引用也都可以指向正确的新地址。此外，在大多数其他GC实现中，引用指向的地址不会被存储在该对象被移动之前的位置；相反，这些地址被存储在一个堆外结构（off-heap structure）中。这样，无需在对所有引用的更新完成之前，再花费精力保持整个内存页完好无损，这个内存页可以被整体回收。\n\n## C4算法真的是无暂停的么？\n\n在C4算法的重映射阶段，正在跟踪引用的线程仅会被中断一次，而这次中断仅仅会持续到对该引用的检索和更新完成，在这次中断后，线程会继续运行。相比于其他并发算法来说，这种实现会带来巨大的性能提升，因为其他的并发立即回收算法需要等到每个线程都运行到一个<i>安全点（safe point）</i>，然后同时挂起所有线程，再开始对所有的引用进行更新，完成后再恢复所有线程的运行。\n\n对于并发压缩垃圾回收器来说，由于垃圾回收所引起的暂停从来都不是问题。在C4算法的重定位阶段中，也不会有再出现更糟的碎片化场景了。实现了C4算法的垃圾回收器也不会出现背靠背（back-to-back）式的垃圾回收周期，或者是因垃圾回收而使应用程序暂停数秒甚至数分钟。如果你曾经体验过这种stop-the-world式的垃圾回收，那么很有可能是你给应用程序设置的内存太小了。你可以试用一下实现了C4算法的垃圾回收器，并为其分配足够多的内存，而完全不必担心暂停时间过长的问题。\n\n## 评估C4算法和其他可选方案\n\n像往常一样，你需要针对应用程序的需求选择一款JVM和垃圾回收器。C4算法在设计之初就是无论堆中活动数据有多少，只要应用程序还有足够的内存可用，暂停时间都始终保持在较低的水平。正因如此，对于那些有大量内存可用，而对响应时间比较敏感的应用程来说，选择实现了C4算法的垃圾回收器正是不二之选。\n\n而对于那些要求快速启动，内存有限的客户端应用程序来说，C4就不是那么适用。而对于那些对吞吐量有较高要求的应用程序来说，C4也并不适用。真正能够发挥C4威力的是那些为了提升应用程序工作负载而在每台服务器上部署了4到16个JVM实例的场景。此外，如果你经常要对垃圾回收器做调优的话，那么不妨考虑一下使用C4算法。综上所述，当响应时间比吞吐量占有更高的优先级时，C4是个不错的选择。而对那些不能接受长时间暂停的应用程序来说，C4是个理想的选择。\n\n如果你正考虑在生产环境中使用C4，那么你可能还需要重新考虑一下如何部署应用程序。例如，不必为每个服务器配置16个具有2GB堆的JVM实例，而是使用一个64GB的JVM实例（或者增加一个作为热备份）。C4需要尽可能大的内存来保证始终有一个空闲内存页来为新创建的对象分配内存。（记住，内存不再是昂贵的资源了！）\n\n如果你没有64GB，128GB，或1TB（或更多）内存可用，那么分布式的多JVM部署可能是一个更好的选择。在这种场景中，你可以考虑使用Oracle HotSpot JVM的G1垃圾回收器，或者IBM JVM的平衡垃圾回收策略（Balanced Garbage Collection Policy）。下面将对这两种垃圾回收器做简单介绍。\n\n## Gargabe-First （G1） 垃圾回收器\n\nG1垃圾回收器是新近才出现的垃圾回收器，是Oracle HotSpot JVM的一部分，在最近的JDK1.6版本中首次出现（译者注，该文章写于2012-07-11）。在启动Oracle JDK时附加命令行选项-XX:+UseG1GC，可以启动G1垃圾回收器。\n\n与C4类似，这款标记-清理（mark-and-sweep）垃圾回收器也可作为对低延迟有要求的应用程序的备选方案。G1算法将堆分为固定大小区域，垃圾回收会作用于其中的某些区域。在应用程序线程运行的同时，启用后台线程，并发的完成标记工作。这点与其他并发标记算法相似。\n\nG1增量方法可以使暂停时间更短，但更频繁，而这对一些力求避免长时间暂停的应用程序来说已经足够了。另一方面，正如在本系列的[Part 3][4]中介绍的，使用G1垃圾回收器需要针对应用程序的实际需求做长时间的调优，而其GC中断又是stop-the-world式的。所以对那些对低延迟有很高要求的应用程序来说，G1并不是一个好的选择。进一步说，从暂停时间总长来看，G1长于CMS（Oracle JVM中广为人知的并发垃圾回收器）。\n\nG1使用拷贝算法（在Part 3中介绍过）完成部分垃圾回收任务。这样，每次垃圾回收器后，都会产生完全可用的空闲空间。G1垃圾回收器定义了一些区域的集合作为年轻代，剩下的作为老年代。\n\nG1已经吸引了足够多的注意，引起了不小的轰动，但是它真正的挑战在于如何应对现实世界的需求。正确的调优就是其中一个挑战 —— 回忆一下，对于动态应用程序负载来说，没有永远“正确的调优”。一个问题是如何处理与分区大小相近的大对象，因为剩余的空间会成为碎片而无法使用。还有一个性能问题始终困扰着低延迟垃圾回收器，那就是垃圾回收器必须管理额外的数据结构。就我来说，使用G1的关键问题在于如何解决stop-the-world式垃圾回收器引起的暂停。Stop-the-world式的垃圾回收引起的暂停使任何垃圾回收器的能力都受制于堆大小和活动数据数量的增长，对企业级Java应用程序的伸缩性来说是一大困扰。\n\n## IBM JVM的平衡垃圾回收策略（Balanced Garbage Collection Policy）\n\nIBM JVM的平衡垃圾回收（Balanced Garbage Collection BGC）策略通过在启动IBM JDK时指定命令行选项-Xgcpolicy:balanced来启用。乍一看，BGC很像G1，它也是将Java堆划分成相同大小的空间，称为区间（region），执行垃圾回收时会对每个区间单独回收。为了达到最佳性能，在选择要执行垃圾回收的区间时使用了一些启发性算法。BGC中关于代的划分也与G1相似。\n\nIBM的平衡垃圾回收策略仅在64位平台得到实现，是一种NUMA架构（Non-Uniform Memory Architecture），设计之初是为了用于具有4GB以上堆的应用程序。由于拷贝算法或压缩算法的需要，BGC的部分垃圾回收工作是stop-the-world式的，并非完全并发完成。所以，归根结底，BGC也会遇到与G1和其他没有实现并发压缩选法的垃圾回收器相似的问题。\n\n### 结论：回顾\n\nC4是基于引用跟踪的、分代式的、并发的、协作式垃圾回收算法，目前只在Azul System公司的Zing JVM得到实现。C4算法的真正价值在于：\n\n> 消除了重标记可能引起的重标记无限循环，也就消除了在标记阶段出现OOM错误的风险。\n\n> 压缩，以自动、且不断重定位的方式消除了固有限制：堆中活动数据越多，压缩所引起的暂停越长。\n\n> 垃圾回收不再是stop-the-world式的，大大降低垃圾回收对应用程序响应时间造成的影响。\n\n> 没有了清理阶段，降低了在完成GC之前就因为空闲内存不足而出现OOM错误的风险。\n\n> 内存可以以页为单位立即回收，使那些需要使用较多内存的Java应用程序有足够的内存可用。\n\n并发压缩是C4独一无二的优势。使应用程序线程GC线程协作运行，保证了应用程序不会因GC而被阻塞。C4将内存分配和提供足够连续空闲内存的能力完全区分开。C4使你可以为JVM实例分配尽可能大的内存，而无需为应用程序暂停而烦恼。使用得当的话，这将是JVM技术的一项革新，它可以借助于当今的多核、TB级内存的硬件优势，大大提升低延迟Java应用程序的运行速度。\n\n如果你不介意一遍又一遍的调优，以及频繁的重启的话，如果你的应用程序适用于水平部署模型的话（即部署几百个小堆JVM实例而不是几个大堆JVM实例），G1也是个不错的选择。\n\n对于<i>动态低延迟启发性自适应（dynamic low-latency heuristic adaption）</i>算法而言，BGC是一项革新，JVM研究者对此算法已经研究了几十年。该算法可以应用于较大的堆。而<i>动态自调优算法（ dynamic self-tuning algorithm）</i>的缺陷是，它无法跟上突然出现的负载高峰。那时，你将不得不面对最糟糕的场景，并根据实际情况再分配相关资源。\n\n最后，为你的应用程序选择最适合的JVM和垃圾回收器时，最重要的考虑因素是应用程序中吞吐量和暂停时间的优先级次序。你想把时间和金钱花在哪？从纯粹的技术角度说，基于我十年来对垃圾回收的经验，我一直在寻找更多关于并发压缩的革新性技术，或其他可以以较小代价完成移动对象或重定位的方法。我想影响企业级Java应用程序伸缩性的关键就在于并发性。\n\n<b>JVM 性能优化系列\n\n第一篇 《[JVM性能优化， Part 1 ―― JVM简介](http://www.importnew.com/1774.html) 》\n\n第二篇《[JVM性能优化， Part 2 ―― 编译器](http://www.importnew.com/2009.html)》\n\n第三篇《[JVM性能优化， Part 3 —— 垃圾回收](http://www.importnew.com/2233.html)》</b>\n\n \n\n<i>原文链接： [javaworld](https://www.infoworld.com/article/2078661/jvm-performance-optimization--part-4--c4-garbage-collection-for-low-latency-java-ap.html) 翻译： [ImportNew.com](www.importnew.com) - [曹旭东](http://www.importnew.com/author/caoxudong)\n译文链接： http://www.importnew.com/2410.html</i>\n","slug":"JVM-性能优化-Part-4-C4-垃圾回收","published":1,"updated":"2020-07-18T04:04:17.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcvei3320002ewip43o60fdn","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><img src=\"http://fahoud.gitee.io/hexo-dist/jvm/JVMlogo.jpg\" alt=\"JVMlogo\"></p>\n<h1 id=\"JVM-性能优化-Part-4-C4-垃圾回收\"><a href=\"#JVM-性能优化-Part-4-C4-垃圾回收\" class=\"headerlink\" title=\"JVM 性能优化, Part 4: C4 垃圾回收\"></a>JVM 性能优化, Part 4: C4 垃圾回收</h1><blockquote>\n<p>ImportNew注：本文是JVM性能优化 系列-第4篇。前3篇文章请参考文章结尾处的JVM优化系列文章。作为Eva Andreasson的JVM性能优化系列的第4篇，本文将对C4垃圾回收器进行介绍。使用C4垃圾回收器可以有效提升对低延迟有要求的企业级Java应用程序的伸缩性。</p>\n</blockquote>\n<p>到目前为止，本系列的文章将stop-the-world式的垃圾回收视为影响Java应用程序伸缩性的一大障碍，而伸缩性又是现代企业级Java应用程序开发的基础要求，因此这一问题亟待改善。幸运的是，针对此问题，JVM中已经出现了一些新特性，所使用的方式或是对stop-the-world式的垃圾回收做微调，或是消除冗长的暂停（这样更好些）。在一些多核系统中，内存不再是稀缺资源，因此，JVM的一些新特性就充分利用多核系统的潜在优势来增强Java应用程序的伸缩性。</p>\n<p>在本文中，我将着重介绍C4算法，该算法是Azul System公司中无暂停垃圾回收算法的新成果，目前只在Zing JVM上得到实现。此外，本文还将对Oracle公司的G1垃圾回收算法和IBM公司的Balanced Garbage Collection Policy算法做简单介绍。希望通过对这些垃圾回收算法的学习可以扩展你对Java内存管理模型和Java应用程序伸缩性的理解，并激发你对这方面内容的兴趣以便更深入的学习相关知识。至少，你可以学习到在选择JVM时有哪些需要关注的方面，以及在不同应用程序场景下要注意的事项。</p>\n<h2 id=\"C4算法中的并发性\"><a href=\"#C4算法中的并发性\" class=\"headerlink\" title=\"C4算法中的并发性\"></a>C4算法中的并发性</h2><p>Azul System公司的C4（Concurrent Continuously Compacting Collector，译者注，Azul官网给出的名字是Continuously Concurrent Compacting Collector）算法使用独一无二而又非常有趣的方法来实现低延迟的分代式垃圾回收。相比于大多数分代式垃圾回收器，C4的不同之处在于它认为垃圾回收并不是什么坏事（即应用程序产生垃圾很正常），而压缩是不可避免的。在设计之初，C4就是要牺牲各种动态内存管理的需求，以满足需要长时间运行的服务器端应用程序的需求。</p>\n<p>C4算法将释放内存的过程从应用程序行为和内存分配速率中分离出来，并加以区分。这样就实现了并发运行，即应用程序可以持续运行，而不必等待垃圾回收的完成。其中的并发性是关键所在，正是由于并发性的存在才可以使暂停时间不受垃圾回收周期内堆上活动数据数量和需要跟踪与更新的引用数量的影响，将暂停时间保持在较低的水平。正如我在本系列第3篇中介绍的一样，大多数垃圾回收器在工作周期内都包含了stop-the-world式的压缩过程，这就是说应用程序的暂停时间会随活动数据总量和堆中对象间引用的复杂度的上升而增加。使用C4算法的垃圾回收器可以并发的执行压缩操作，即压缩与应用程序线程同时工作，从而解决了影响JVM伸缩性的最大难题。</p>\n<p>实际上，为了实现并发性，C4算法改变了现代Java企业级架构和部署模型的基本假设。想象一下拥有数百GB内存的JVM会是什么样的：</p>\n<ul>\n<li><p>部署Java应用程序时，对伸缩性的要求无需要多个JVM配合，在单一JVM实例中即可完成。这时的部署是什么样呢？</p>\n</li>\n<li><p>有哪些以往因GC限制而无法在内存存储的对象？</p>\n</li>\n<li><p>那些分布式集群（如缓存服务器、区域服务器，或其他类型的服务器节点）会有什么变化？当可以增加JVM内存而不会对应用程序响应时间造成负面影响时，传统的节点数量、节点死亡和缓存丢失的计算会有什么变化呢？</p>\n</li>\n</ul>\n<h2 id=\"C4算法的3的阶段\"><a href=\"#C4算法的3的阶段\" class=\"headerlink\" title=\"C4算法的3的阶段\"></a>C4算法的3的阶段</h2><p>C4算法的一个基本假设是“垃圾回收不是坏事”和“压缩不可避免”。C4算法的设计目标是实现垃圾回收的并发与协作，剔除stop-the-world式的垃圾回收。C4垃圾回收算法包含一下3个阶段：</p>\n<blockquote>\n<ol>\n<li><i>标记（Marking）</i> — 找到活动对象</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li><i>重定位（Relocation）</i> — 将存活对象移动到一起，以便可以释放较大的连续空间，这个阶段也可称为“压缩（compaction）”</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"3\">\n<li><i>重映射（Remapping）</i> — 更新被移动的对象的引用。</li>\n</ol>\n</blockquote>\n<p>下面的内容将对每个阶段做详细介绍。</p>\n<h2 id=\"C4算法中的标记阶段\"><a href=\"#C4算法中的标记阶段\" class=\"headerlink\" title=\"C4算法中的标记阶段\"></a>C4算法中的标记阶段</h2><p>在C4算法中，<i>标记阶段（marking phase）</i>使用了<i>并发标记（concurrent marking）</i>和<i>引用跟踪（reference-tracing）</i>的方法来标记活动对象，这方面内容已经在本系列的第3篇中介绍过。</p>\n<p>在标记阶段中，GC线程会从线程栈和寄存器中的活动对象开始，遍历所有的引用，标记找到的对象，这些GC线程会遍历堆上所有的<i>可达（reachable）</i>对象。在这个阶段，C4算法与其他并发标记器的工作方式非常相似。</p>\n<p>C4算法的标记器与其他并发标记器的区别也是始于并发标记阶段的。在并发标记阶段中，如果应用程序线程修改未标记的对象，那么该对象会被放到一个队列中，以备遍历。这就保证了该对象最终会被标记，也因为如此，C4垃圾回收器或另一个应用程序线程不会重复遍历该对象。这样就节省了标记时间，消除了<i>递归重标记（recursive remark）</i>的风险。（注意，长时间的递归重标记有可能会使应用程序因无法获得足够的内存而抛出<b>OOM错误</b>，这也是大部分垃圾回收场景中的普遍问题。）</p>\n<p><img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmperf4.png\" alt=\"Figure 1\"></p>\n<center style=\"font-size:14px;color:#444043;text-decoration:none\">Figure 1. Application threads traverse the heap just once during marking</center>\n\n\n<p>如果C4算法的实现是基于<i>脏卡表（dirty-card tables）</i>或其他对已经遍历过的堆区域的读写操作进行记录的方法，那垃圾回收线程就需要重新访问这些区域做重标记。在极端条件下，垃圾回收线程会陷入到永无止境的重标记中 —— 至少这个过程可能会长到使应用程序因无法分配到新的内存而抛出OOM错误。但C4算法是基于LVB（load value barrier）实现的，LVB具有自愈能力，可以使应用程序线程迅速查明某个引用是否已经被标记过了。如果这个引用没有被标记过，那么应用程序会将其添加到GC队列中。一旦该引用被放入到队列中，它就不会再被重标记了。应用程序线程可以继续做它自己的事。</p>\n<blockquote>\n<p><i>脏对象（dirty object）和卡表（card table）</i></p>\n</blockquote>\n<p>由于某些原因（例如在一个并发垃圾回收周期中，对象被修改了），垃圾回收器需要重新访问某些对象，那么这些对象脏对象（dirty object）。这这些脏对象，或堆中脏区域的引用，通过会记录在一个专门的数据结构中，这就是卡表。</p>\n<p>在C4算法中，并没有<i>重标记（re-marking）</i>这个阶段，在第一次便利整个堆时就会将所有可达对象做标记。因为运行时不需要做重标记，也就不会陷入无限循环的重标记陷阱中，由此而降低了应用程序因无法分配到内存而抛出OOM错误的风险。</p>\n<h2 id=\"C4算法中的重定位-——-应用程序线程与GC的协作\"><a href=\"#C4算法中的重定位-——-应用程序线程与GC的协作\" class=\"headerlink\" title=\"C4算法中的重定位 ——　应用程序线程与GC的协作\"></a>C4算法中的重定位 ——　应用程序线程与GC的协作</h2><p>C4算法中，<i>重定位阶段（reloacation phase）</i>是由GC线程和应用程序线程以协作的方式，并发完成的。这是因为GC线程和应用程序线程会同时工作，而且无论哪个线程先访问将被移动的对象，都会以协作的方式帮助完成该对象的移动任务。因此，应用程序线程可以继续执行自己的任务，而不必等待整个垃圾回收周期的完成。</p>\n<p>正如Figure 2所示，碎片内存页中的活动对象会被重定位。在这个例子中，应用程序线程先访问了要被移动的对象，那么应用程序线程也会帮助完成移动该对象的工作的初始部分，这样，它就可以很快的继续做自己的任务。虚拟地址（指相关引用）可以指向新的正确位置，内存也可以快速回收。</p>\n<p><img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmperf5.png\" alt=\"Figure 2\"></p>\n<center style=\"font-size:14px;color:#444043;text-decoration:none\">Figure 2. A page selected for relocation and the empty new page that it will be moved to</center>\n\n\n<p>如果是GC线程先访问到了将被移动的对象，那事情就简单多了，GC线程会执行移动操作的。如果在<i>重映射阶段（re-mapping phase，后续会提到）</i>也访问这个对象，那么它必须检查该对象是否是要被移动的。如果是，那么应用程序线程会重新定位这个对象的位置，以便可以继续完成自己任务。（对大对象的移动是通过将该对象打碎再移动完成的。如果你对这部分内容感兴趣的话，推荐你阅读一下相关资源中的这篇白皮书“C4: The Continuously Concurrent Compacting Collector”）</p>\n<p>当所有的活动对象都从某个内存也中移出后，剩下的就都是垃圾数据了，这个内存页也就可以被整体回收了。正如Figure 2中所示。</p>\n<blockquote>\n<p>关于清理</p>\n</blockquote>\n<p>在C4算法中并没有清理阶段（sweep phase），因此也就不需要这个在大多数垃圾回收算法中比较常用的操作。在指向被移动的对象的引用都更新为指向新的位置之前，from页中的虚拟地址空间必须被完整保留。所以C4算法的实现保证了，在所有指向这个页的引用处于稳定状态前，所有的虚拟地址空间都会被锁定。然后，算法会立即回收物理内存页。</p>\n<p>很明显，无需执行stop-the-world式的移动对象是有很大好处的。由于在重定位阶段，所有活动对象都是并发移动的，因此它们可以被更有效率的放入到相邻的地址中，并且可以充分的压缩。通过并发执行重定位操作，堆被压缩为连续空间，也无需挂起所有的应用程序线程。这种方式消除了Java应用程序访问内存的传统限制（更多关于Java应用程序内存模型的内容参见ImportNew编译整理的第一篇《<a href=\"http://www.importnew.com/1774.html\" target=\"_blank\" rel=\"noopener\">JVM性能优化， Part 1 ―― JVM简介</a>》）。</p>\n<p>经过上述的过程后，如何更新引用呢？如何实现一个非stop-the-world式的操作呢？</p>\n<h2 id=\"C4算法中的重映射\"><a href=\"#C4算法中的重映射\" class=\"headerlink\" title=\"C4算法中的重映射\"></a>C4算法中的重映射</h2><p>在重定位阶段，某些指向被移动的对象的引用会自动更新。但是，在重定位阶段，那些指向了被移动的对象的引用并没有更新，仍然指向原处，所以它们需要在后续完成更新操作。C4算法中的重映射阶段（re-mapping phase）负责完成对那些活动对象已经移出，但仍指向那些的引用进行更新。当然，重映射也是一个协作式的并发操作。</p>\n<p>Figure 3中，在重定位阶段，活动对象已经被移动到了一个新的内存页中。在重定位之后，GC线程立即开始更新那些仍然指向之前的虚拟地址空间的引用，将它们指向那些被移动的对象的新地址。垃圾回收器会一直执行此项任务，直到所有的引用都被更新，这样原先虚拟内存空间就可以被整体回收了。</p>\n<p><img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmperf6.png\" alt=\"Figure 3\"></p>\n<center style=\"font-size:14px;color:#444043;text-decoration:none\">Figure 3. Whatever thread finds an invalid address enables an update to the correct new address</center>\n\n\n<p>但如果在GC完成对所有引用的更新之前，应用程序线程想要访问这些引用的话，会出现什么情况呢？在C4算法中，应用程序线程可以很方便的帮助完成对引用进行更新的工作。如果在重映射阶段，应用程序线程访问了处于非稳定状态的引用，它会找到该引用的正确指向。如果应用程序线程找到了正确的引用，它会更新该引用的指向。当完成更新后，应用程序线程会继续自己的工作。</p>\n<p>协作式的重映射保证了引用只会被更新一次，该引用下的子引用也都可以指向正确的新地址。此外，在大多数其他GC实现中，引用指向的地址不会被存储在该对象被移动之前的位置；相反，这些地址被存储在一个堆外结构（off-heap structure）中。这样，无需在对所有引用的更新完成之前，再花费精力保持整个内存页完好无损，这个内存页可以被整体回收。</p>\n<h2 id=\"C4算法真的是无暂停的么？\"><a href=\"#C4算法真的是无暂停的么？\" class=\"headerlink\" title=\"C4算法真的是无暂停的么？\"></a>C4算法真的是无暂停的么？</h2><p>在C4算法的重映射阶段，正在跟踪引用的线程仅会被中断一次，而这次中断仅仅会持续到对该引用的检索和更新完成，在这次中断后，线程会继续运行。相比于其他并发算法来说，这种实现会带来巨大的性能提升，因为其他的并发立即回收算法需要等到每个线程都运行到一个<i>安全点（safe point）</i>，然后同时挂起所有线程，再开始对所有的引用进行更新，完成后再恢复所有线程的运行。</p>\n<p>对于并发压缩垃圾回收器来说，由于垃圾回收所引起的暂停从来都不是问题。在C4算法的重定位阶段中，也不会有再出现更糟的碎片化场景了。实现了C4算法的垃圾回收器也不会出现背靠背（back-to-back）式的垃圾回收周期，或者是因垃圾回收而使应用程序暂停数秒甚至数分钟。如果你曾经体验过这种stop-the-world式的垃圾回收，那么很有可能是你给应用程序设置的内存太小了。你可以试用一下实现了C4算法的垃圾回收器，并为其分配足够多的内存，而完全不必担心暂停时间过长的问题。</p>\n<h2 id=\"评估C4算法和其他可选方案\"><a href=\"#评估C4算法和其他可选方案\" class=\"headerlink\" title=\"评估C4算法和其他可选方案\"></a>评估C4算法和其他可选方案</h2><p>像往常一样，你需要针对应用程序的需求选择一款JVM和垃圾回收器。C4算法在设计之初就是无论堆中活动数据有多少，只要应用程序还有足够的内存可用，暂停时间都始终保持在较低的水平。正因如此，对于那些有大量内存可用，而对响应时间比较敏感的应用程来说，选择实现了C4算法的垃圾回收器正是不二之选。</p>\n<p>而对于那些要求快速启动，内存有限的客户端应用程序来说，C4就不是那么适用。而对于那些对吞吐量有较高要求的应用程序来说，C4也并不适用。真正能够发挥C4威力的是那些为了提升应用程序工作负载而在每台服务器上部署了4到16个JVM实例的场景。此外，如果你经常要对垃圾回收器做调优的话，那么不妨考虑一下使用C4算法。综上所述，当响应时间比吞吐量占有更高的优先级时，C4是个不错的选择。而对那些不能接受长时间暂停的应用程序来说，C4是个理想的选择。</p>\n<p>如果你正考虑在生产环境中使用C4，那么你可能还需要重新考虑一下如何部署应用程序。例如，不必为每个服务器配置16个具有2GB堆的JVM实例，而是使用一个64GB的JVM实例（或者增加一个作为热备份）。C4需要尽可能大的内存来保证始终有一个空闲内存页来为新创建的对象分配内存。（记住，内存不再是昂贵的资源了！）</p>\n<p>如果你没有64GB，128GB，或1TB（或更多）内存可用，那么分布式的多JVM部署可能是一个更好的选择。在这种场景中，你可以考虑使用Oracle HotSpot JVM的G1垃圾回收器，或者IBM JVM的平衡垃圾回收策略（Balanced Garbage Collection Policy）。下面将对这两种垃圾回收器做简单介绍。</p>\n<h2 id=\"Gargabe-First-（G1）-垃圾回收器\"><a href=\"#Gargabe-First-（G1）-垃圾回收器\" class=\"headerlink\" title=\"Gargabe-First （G1） 垃圾回收器\"></a>Gargabe-First （G1） 垃圾回收器</h2><p>G1垃圾回收器是新近才出现的垃圾回收器，是Oracle HotSpot JVM的一部分，在最近的JDK1.6版本中首次出现（译者注，该文章写于2012-07-11）。在启动Oracle JDK时附加命令行选项-XX:+UseG1GC，可以启动G1垃圾回收器。</p>\n<p>与C4类似，这款标记-清理（mark-and-sweep）垃圾回收器也可作为对低延迟有要求的应用程序的备选方案。G1算法将堆分为固定大小区域，垃圾回收会作用于其中的某些区域。在应用程序线程运行的同时，启用后台线程，并发的完成标记工作。这点与其他并发标记算法相似。</p>\n<p>G1增量方法可以使暂停时间更短，但更频繁，而这对一些力求避免长时间暂停的应用程序来说已经足够了。另一方面，正如在本系列的[Part 3][4]中介绍的，使用G1垃圾回收器需要针对应用程序的实际需求做长时间的调优，而其GC中断又是stop-the-world式的。所以对那些对低延迟有很高要求的应用程序来说，G1并不是一个好的选择。进一步说，从暂停时间总长来看，G1长于CMS（Oracle JVM中广为人知的并发垃圾回收器）。</p>\n<p>G1使用拷贝算法（在Part 3中介绍过）完成部分垃圾回收任务。这样，每次垃圾回收器后，都会产生完全可用的空闲空间。G1垃圾回收器定义了一些区域的集合作为年轻代，剩下的作为老年代。</p>\n<p>G1已经吸引了足够多的注意，引起了不小的轰动，但是它真正的挑战在于如何应对现实世界的需求。正确的调优就是其中一个挑战 —— 回忆一下，对于动态应用程序负载来说，没有永远“正确的调优”。一个问题是如何处理与分区大小相近的大对象，因为剩余的空间会成为碎片而无法使用。还有一个性能问题始终困扰着低延迟垃圾回收器，那就是垃圾回收器必须管理额外的数据结构。就我来说，使用G1的关键问题在于如何解决stop-the-world式垃圾回收器引起的暂停。Stop-the-world式的垃圾回收引起的暂停使任何垃圾回收器的能力都受制于堆大小和活动数据数量的增长，对企业级Java应用程序的伸缩性来说是一大困扰。</p>\n<h2 id=\"IBM-JVM的平衡垃圾回收策略（Balanced-Garbage-Collection-Policy）\"><a href=\"#IBM-JVM的平衡垃圾回收策略（Balanced-Garbage-Collection-Policy）\" class=\"headerlink\" title=\"IBM JVM的平衡垃圾回收策略（Balanced Garbage Collection Policy）\"></a>IBM JVM的平衡垃圾回收策略（Balanced Garbage Collection Policy）</h2><p>IBM JVM的平衡垃圾回收（Balanced Garbage Collection BGC）策略通过在启动IBM JDK时指定命令行选项-Xgcpolicy:balanced来启用。乍一看，BGC很像G1，它也是将Java堆划分成相同大小的空间，称为区间（region），执行垃圾回收时会对每个区间单独回收。为了达到最佳性能，在选择要执行垃圾回收的区间时使用了一些启发性算法。BGC中关于代的划分也与G1相似。</p>\n<p>IBM的平衡垃圾回收策略仅在64位平台得到实现，是一种NUMA架构（Non-Uniform Memory Architecture），设计之初是为了用于具有4GB以上堆的应用程序。由于拷贝算法或压缩算法的需要，BGC的部分垃圾回收工作是stop-the-world式的，并非完全并发完成。所以，归根结底，BGC也会遇到与G1和其他没有实现并发压缩选法的垃圾回收器相似的问题。</p>\n<h3 id=\"结论：回顾\"><a href=\"#结论：回顾\" class=\"headerlink\" title=\"结论：回顾\"></a>结论：回顾</h3><p>C4是基于引用跟踪的、分代式的、并发的、协作式垃圾回收算法，目前只在Azul System公司的Zing JVM得到实现。C4算法的真正价值在于：</p>\n<blockquote>\n<p>消除了重标记可能引起的重标记无限循环，也就消除了在标记阶段出现OOM错误的风险。</p>\n</blockquote>\n<blockquote>\n<p>压缩，以自动、且不断重定位的方式消除了固有限制：堆中活动数据越多，压缩所引起的暂停越长。</p>\n</blockquote>\n<blockquote>\n<p>垃圾回收不再是stop-the-world式的，大大降低垃圾回收对应用程序响应时间造成的影响。</p>\n</blockquote>\n<blockquote>\n<p>没有了清理阶段，降低了在完成GC之前就因为空闲内存不足而出现OOM错误的风险。</p>\n</blockquote>\n<blockquote>\n<p>内存可以以页为单位立即回收，使那些需要使用较多内存的Java应用程序有足够的内存可用。</p>\n</blockquote>\n<p>并发压缩是C4独一无二的优势。使应用程序线程GC线程协作运行，保证了应用程序不会因GC而被阻塞。C4将内存分配和提供足够连续空闲内存的能力完全区分开。C4使你可以为JVM实例分配尽可能大的内存，而无需为应用程序暂停而烦恼。使用得当的话，这将是JVM技术的一项革新，它可以借助于当今的多核、TB级内存的硬件优势，大大提升低延迟Java应用程序的运行速度。</p>\n<p>如果你不介意一遍又一遍的调优，以及频繁的重启的话，如果你的应用程序适用于水平部署模型的话（即部署几百个小堆JVM实例而不是几个大堆JVM实例），G1也是个不错的选择。</p>\n<p>对于<i>动态低延迟启发性自适应（dynamic low-latency heuristic adaption）</i>算法而言，BGC是一项革新，JVM研究者对此算法已经研究了几十年。该算法可以应用于较大的堆。而<i>动态自调优算法（ dynamic self-tuning algorithm）</i>的缺陷是，它无法跟上突然出现的负载高峰。那时，你将不得不面对最糟糕的场景，并根据实际情况再分配相关资源。</p>\n<p>最后，为你的应用程序选择最适合的JVM和垃圾回收器时，最重要的考虑因素是应用程序中吞吐量和暂停时间的优先级次序。你想把时间和金钱花在哪？从纯粹的技术角度说，基于我十年来对垃圾回收的经验，我一直在寻找更多关于并发压缩的革新性技术，或其他可以以较小代价完成移动对象或重定位的方法。我想影响企业级Java应用程序伸缩性的关键就在于并发性。</p>\n<p><b>JVM 性能优化系列</p>\n<p>第一篇 《<a href=\"http://www.importnew.com/1774.html\" target=\"_blank\" rel=\"noopener\">JVM性能优化， Part 1 ―― JVM简介</a> 》</p>\n<p>第二篇《<a href=\"http://www.importnew.com/2009.html\" target=\"_blank\" rel=\"noopener\">JVM性能优化， Part 2 ―― 编译器</a>》</p>\n<p>第三篇《<a href=\"http://www.importnew.com/2233.html\" target=\"_blank\" rel=\"noopener\">JVM性能优化， Part 3 —— 垃圾回收</a>》</b></p>\n<p><i>原文链接： <a href=\"https://www.infoworld.com/article/2078661/jvm-performance-optimization--part-4--c4-garbage-collection-for-low-latency-java-ap.html\" target=\"_blank\" rel=\"noopener\">javaworld</a> 翻译： <a href=\"www.importnew.com\">ImportNew.com</a> - <a href=\"http://www.importnew.com/author/caoxudong\" target=\"_blank\" rel=\"noopener\">曹旭东</a><br>译文链接： <a href=\"http://www.importnew.com/2410.html\" target=\"_blank\" rel=\"noopener\">http://www.importnew.com/2410.html</a></i></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://fahoud.gitee.io/hexo-dist/jvm/JVMlogo.jpg\" alt=\"JVMlogo\"></p>\n<h1 id=\"JVM-性能优化-Part-4-C4-垃圾回收\"><a href=\"#JVM-性能优化-Part-4-C4-垃圾回收\" class=\"headerlink\" title=\"JVM 性能优化, Part 4: C4 垃圾回收\"></a>JVM 性能优化, Part 4: C4 垃圾回收</h1><blockquote>\n<p>ImportNew注：本文是JVM性能优化 系列-第4篇。前3篇文章请参考文章结尾处的JVM优化系列文章。作为Eva Andreasson的JVM性能优化系列的第4篇，本文将对C4垃圾回收器进行介绍。使用C4垃圾回收器可以有效提升对低延迟有要求的企业级Java应用程序的伸缩性。</p>\n</blockquote>\n<p>到目前为止，本系列的文章将stop-the-world式的垃圾回收视为影响Java应用程序伸缩性的一大障碍，而伸缩性又是现代企业级Java应用程序开发的基础要求，因此这一问题亟待改善。幸运的是，针对此问题，JVM中已经出现了一些新特性，所使用的方式或是对stop-the-world式的垃圾回收做微调，或是消除冗长的暂停（这样更好些）。在一些多核系统中，内存不再是稀缺资源，因此，JVM的一些新特性就充分利用多核系统的潜在优势来增强Java应用程序的伸缩性。</p>\n<p>在本文中，我将着重介绍C4算法，该算法是Azul System公司中无暂停垃圾回收算法的新成果，目前只在Zing JVM上得到实现。此外，本文还将对Oracle公司的G1垃圾回收算法和IBM公司的Balanced Garbage Collection Policy算法做简单介绍。希望通过对这些垃圾回收算法的学习可以扩展你对Java内存管理模型和Java应用程序伸缩性的理解，并激发你对这方面内容的兴趣以便更深入的学习相关知识。至少，你可以学习到在选择JVM时有哪些需要关注的方面，以及在不同应用程序场景下要注意的事项。</p>\n<h2 id=\"C4算法中的并发性\"><a href=\"#C4算法中的并发性\" class=\"headerlink\" title=\"C4算法中的并发性\"></a>C4算法中的并发性</h2><p>Azul System公司的C4（Concurrent Continuously Compacting Collector，译者注，Azul官网给出的名字是Continuously Concurrent Compacting Collector）算法使用独一无二而又非常有趣的方法来实现低延迟的分代式垃圾回收。相比于大多数分代式垃圾回收器，C4的不同之处在于它认为垃圾回收并不是什么坏事（即应用程序产生垃圾很正常），而压缩是不可避免的。在设计之初，C4就是要牺牲各种动态内存管理的需求，以满足需要长时间运行的服务器端应用程序的需求。</p>\n<p>C4算法将释放内存的过程从应用程序行为和内存分配速率中分离出来，并加以区分。这样就实现了并发运行，即应用程序可以持续运行，而不必等待垃圾回收的完成。其中的并发性是关键所在，正是由于并发性的存在才可以使暂停时间不受垃圾回收周期内堆上活动数据数量和需要跟踪与更新的引用数量的影响，将暂停时间保持在较低的水平。正如我在本系列第3篇中介绍的一样，大多数垃圾回收器在工作周期内都包含了stop-the-world式的压缩过程，这就是说应用程序的暂停时间会随活动数据总量和堆中对象间引用的复杂度的上升而增加。使用C4算法的垃圾回收器可以并发的执行压缩操作，即压缩与应用程序线程同时工作，从而解决了影响JVM伸缩性的最大难题。</p>\n<p>实际上，为了实现并发性，C4算法改变了现代Java企业级架构和部署模型的基本假设。想象一下拥有数百GB内存的JVM会是什么样的：</p>\n<ul>\n<li><p>部署Java应用程序时，对伸缩性的要求无需要多个JVM配合，在单一JVM实例中即可完成。这时的部署是什么样呢？</p>\n</li>\n<li><p>有哪些以往因GC限制而无法在内存存储的对象？</p>\n</li>\n<li><p>那些分布式集群（如缓存服务器、区域服务器，或其他类型的服务器节点）会有什么变化？当可以增加JVM内存而不会对应用程序响应时间造成负面影响时，传统的节点数量、节点死亡和缓存丢失的计算会有什么变化呢？</p>\n</li>\n</ul>\n<h2 id=\"C4算法的3的阶段\"><a href=\"#C4算法的3的阶段\" class=\"headerlink\" title=\"C4算法的3的阶段\"></a>C4算法的3的阶段</h2><p>C4算法的一个基本假设是“垃圾回收不是坏事”和“压缩不可避免”。C4算法的设计目标是实现垃圾回收的并发与协作，剔除stop-the-world式的垃圾回收。C4垃圾回收算法包含一下3个阶段：</p>\n<blockquote>\n<ol>\n<li><i>标记（Marking）</i> — 找到活动对象</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li><i>重定位（Relocation）</i> — 将存活对象移动到一起，以便可以释放较大的连续空间，这个阶段也可称为“压缩（compaction）”</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"3\">\n<li><i>重映射（Remapping）</i> — 更新被移动的对象的引用。</li>\n</ol>\n</blockquote>\n<p>下面的内容将对每个阶段做详细介绍。</p>\n<h2 id=\"C4算法中的标记阶段\"><a href=\"#C4算法中的标记阶段\" class=\"headerlink\" title=\"C4算法中的标记阶段\"></a>C4算法中的标记阶段</h2><p>在C4算法中，<i>标记阶段（marking phase）</i>使用了<i>并发标记（concurrent marking）</i>和<i>引用跟踪（reference-tracing）</i>的方法来标记活动对象，这方面内容已经在本系列的第3篇中介绍过。</p>\n<p>在标记阶段中，GC线程会从线程栈和寄存器中的活动对象开始，遍历所有的引用，标记找到的对象，这些GC线程会遍历堆上所有的<i>可达（reachable）</i>对象。在这个阶段，C4算法与其他并发标记器的工作方式非常相似。</p>\n<p>C4算法的标记器与其他并发标记器的区别也是始于并发标记阶段的。在并发标记阶段中，如果应用程序线程修改未标记的对象，那么该对象会被放到一个队列中，以备遍历。这就保证了该对象最终会被标记，也因为如此，C4垃圾回收器或另一个应用程序线程不会重复遍历该对象。这样就节省了标记时间，消除了<i>递归重标记（recursive remark）</i>的风险。（注意，长时间的递归重标记有可能会使应用程序因无法获得足够的内存而抛出<b>OOM错误</b>，这也是大部分垃圾回收场景中的普遍问题。）</p>\n<p><img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmperf4.png\" alt=\"Figure 1\"></p>\n<center style=\"font-size:14px;color:#444043;text-decoration:none\">Figure 1. Application threads traverse the heap just once during marking</center>\n\n\n<p>如果C4算法的实现是基于<i>脏卡表（dirty-card tables）</i>或其他对已经遍历过的堆区域的读写操作进行记录的方法，那垃圾回收线程就需要重新访问这些区域做重标记。在极端条件下，垃圾回收线程会陷入到永无止境的重标记中 —— 至少这个过程可能会长到使应用程序因无法分配到新的内存而抛出OOM错误。但C4算法是基于LVB（load value barrier）实现的，LVB具有自愈能力，可以使应用程序线程迅速查明某个引用是否已经被标记过了。如果这个引用没有被标记过，那么应用程序会将其添加到GC队列中。一旦该引用被放入到队列中，它就不会再被重标记了。应用程序线程可以继续做它自己的事。</p>\n<blockquote>\n<p><i>脏对象（dirty object）和卡表（card table）</i></p>\n</blockquote>\n<p>由于某些原因（例如在一个并发垃圾回收周期中，对象被修改了），垃圾回收器需要重新访问某些对象，那么这些对象脏对象（dirty object）。这这些脏对象，或堆中脏区域的引用，通过会记录在一个专门的数据结构中，这就是卡表。</p>\n<p>在C4算法中，并没有<i>重标记（re-marking）</i>这个阶段，在第一次便利整个堆时就会将所有可达对象做标记。因为运行时不需要做重标记，也就不会陷入无限循环的重标记陷阱中，由此而降低了应用程序因无法分配到内存而抛出OOM错误的风险。</p>\n<h2 id=\"C4算法中的重定位-——-应用程序线程与GC的协作\"><a href=\"#C4算法中的重定位-——-应用程序线程与GC的协作\" class=\"headerlink\" title=\"C4算法中的重定位 ——　应用程序线程与GC的协作\"></a>C4算法中的重定位 ——　应用程序线程与GC的协作</h2><p>C4算法中，<i>重定位阶段（reloacation phase）</i>是由GC线程和应用程序线程以协作的方式，并发完成的。这是因为GC线程和应用程序线程会同时工作，而且无论哪个线程先访问将被移动的对象，都会以协作的方式帮助完成该对象的移动任务。因此，应用程序线程可以继续执行自己的任务，而不必等待整个垃圾回收周期的完成。</p>\n<p>正如Figure 2所示，碎片内存页中的活动对象会被重定位。在这个例子中，应用程序线程先访问了要被移动的对象，那么应用程序线程也会帮助完成移动该对象的工作的初始部分，这样，它就可以很快的继续做自己的任务。虚拟地址（指相关引用）可以指向新的正确位置，内存也可以快速回收。</p>\n<p><img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmperf5.png\" alt=\"Figure 2\"></p>\n<center style=\"font-size:14px;color:#444043;text-decoration:none\">Figure 2. A page selected for relocation and the empty new page that it will be moved to</center>\n\n\n<p>如果是GC线程先访问到了将被移动的对象，那事情就简单多了，GC线程会执行移动操作的。如果在<i>重映射阶段（re-mapping phase，后续会提到）</i>也访问这个对象，那么它必须检查该对象是否是要被移动的。如果是，那么应用程序线程会重新定位这个对象的位置，以便可以继续完成自己任务。（对大对象的移动是通过将该对象打碎再移动完成的。如果你对这部分内容感兴趣的话，推荐你阅读一下相关资源中的这篇白皮书“C4: The Continuously Concurrent Compacting Collector”）</p>\n<p>当所有的活动对象都从某个内存也中移出后，剩下的就都是垃圾数据了，这个内存页也就可以被整体回收了。正如Figure 2中所示。</p>\n<blockquote>\n<p>关于清理</p>\n</blockquote>\n<p>在C4算法中并没有清理阶段（sweep phase），因此也就不需要这个在大多数垃圾回收算法中比较常用的操作。在指向被移动的对象的引用都更新为指向新的位置之前，from页中的虚拟地址空间必须被完整保留。所以C4算法的实现保证了，在所有指向这个页的引用处于稳定状态前，所有的虚拟地址空间都会被锁定。然后，算法会立即回收物理内存页。</p>\n<p>很明显，无需执行stop-the-world式的移动对象是有很大好处的。由于在重定位阶段，所有活动对象都是并发移动的，因此它们可以被更有效率的放入到相邻的地址中，并且可以充分的压缩。通过并发执行重定位操作，堆被压缩为连续空间，也无需挂起所有的应用程序线程。这种方式消除了Java应用程序访问内存的传统限制（更多关于Java应用程序内存模型的内容参见ImportNew编译整理的第一篇《<a href=\"http://www.importnew.com/1774.html\" target=\"_blank\" rel=\"noopener\">JVM性能优化， Part 1 ―― JVM简介</a>》）。</p>\n<p>经过上述的过程后，如何更新引用呢？如何实现一个非stop-the-world式的操作呢？</p>\n<h2 id=\"C4算法中的重映射\"><a href=\"#C4算法中的重映射\" class=\"headerlink\" title=\"C4算法中的重映射\"></a>C4算法中的重映射</h2><p>在重定位阶段，某些指向被移动的对象的引用会自动更新。但是，在重定位阶段，那些指向了被移动的对象的引用并没有更新，仍然指向原处，所以它们需要在后续完成更新操作。C4算法中的重映射阶段（re-mapping phase）负责完成对那些活动对象已经移出，但仍指向那些的引用进行更新。当然，重映射也是一个协作式的并发操作。</p>\n<p>Figure 3中，在重定位阶段，活动对象已经被移动到了一个新的内存页中。在重定位之后，GC线程立即开始更新那些仍然指向之前的虚拟地址空间的引用，将它们指向那些被移动的对象的新地址。垃圾回收器会一直执行此项任务，直到所有的引用都被更新，这样原先虚拟内存空间就可以被整体回收了。</p>\n<p><img src=\"http://fahoud.gitee.io/hexo-dist/jvm/jvmperf6.png\" alt=\"Figure 3\"></p>\n<center style=\"font-size:14px;color:#444043;text-decoration:none\">Figure 3. Whatever thread finds an invalid address enables an update to the correct new address</center>\n\n\n<p>但如果在GC完成对所有引用的更新之前，应用程序线程想要访问这些引用的话，会出现什么情况呢？在C4算法中，应用程序线程可以很方便的帮助完成对引用进行更新的工作。如果在重映射阶段，应用程序线程访问了处于非稳定状态的引用，它会找到该引用的正确指向。如果应用程序线程找到了正确的引用，它会更新该引用的指向。当完成更新后，应用程序线程会继续自己的工作。</p>\n<p>协作式的重映射保证了引用只会被更新一次，该引用下的子引用也都可以指向正确的新地址。此外，在大多数其他GC实现中，引用指向的地址不会被存储在该对象被移动之前的位置；相反，这些地址被存储在一个堆外结构（off-heap structure）中。这样，无需在对所有引用的更新完成之前，再花费精力保持整个内存页完好无损，这个内存页可以被整体回收。</p>\n<h2 id=\"C4算法真的是无暂停的么？\"><a href=\"#C4算法真的是无暂停的么？\" class=\"headerlink\" title=\"C4算法真的是无暂停的么？\"></a>C4算法真的是无暂停的么？</h2><p>在C4算法的重映射阶段，正在跟踪引用的线程仅会被中断一次，而这次中断仅仅会持续到对该引用的检索和更新完成，在这次中断后，线程会继续运行。相比于其他并发算法来说，这种实现会带来巨大的性能提升，因为其他的并发立即回收算法需要等到每个线程都运行到一个<i>安全点（safe point）</i>，然后同时挂起所有线程，再开始对所有的引用进行更新，完成后再恢复所有线程的运行。</p>\n<p>对于并发压缩垃圾回收器来说，由于垃圾回收所引起的暂停从来都不是问题。在C4算法的重定位阶段中，也不会有再出现更糟的碎片化场景了。实现了C4算法的垃圾回收器也不会出现背靠背（back-to-back）式的垃圾回收周期，或者是因垃圾回收而使应用程序暂停数秒甚至数分钟。如果你曾经体验过这种stop-the-world式的垃圾回收，那么很有可能是你给应用程序设置的内存太小了。你可以试用一下实现了C4算法的垃圾回收器，并为其分配足够多的内存，而完全不必担心暂停时间过长的问题。</p>\n<h2 id=\"评估C4算法和其他可选方案\"><a href=\"#评估C4算法和其他可选方案\" class=\"headerlink\" title=\"评估C4算法和其他可选方案\"></a>评估C4算法和其他可选方案</h2><p>像往常一样，你需要针对应用程序的需求选择一款JVM和垃圾回收器。C4算法在设计之初就是无论堆中活动数据有多少，只要应用程序还有足够的内存可用，暂停时间都始终保持在较低的水平。正因如此，对于那些有大量内存可用，而对响应时间比较敏感的应用程来说，选择实现了C4算法的垃圾回收器正是不二之选。</p>\n<p>而对于那些要求快速启动，内存有限的客户端应用程序来说，C4就不是那么适用。而对于那些对吞吐量有较高要求的应用程序来说，C4也并不适用。真正能够发挥C4威力的是那些为了提升应用程序工作负载而在每台服务器上部署了4到16个JVM实例的场景。此外，如果你经常要对垃圾回收器做调优的话，那么不妨考虑一下使用C4算法。综上所述，当响应时间比吞吐量占有更高的优先级时，C4是个不错的选择。而对那些不能接受长时间暂停的应用程序来说，C4是个理想的选择。</p>\n<p>如果你正考虑在生产环境中使用C4，那么你可能还需要重新考虑一下如何部署应用程序。例如，不必为每个服务器配置16个具有2GB堆的JVM实例，而是使用一个64GB的JVM实例（或者增加一个作为热备份）。C4需要尽可能大的内存来保证始终有一个空闲内存页来为新创建的对象分配内存。（记住，内存不再是昂贵的资源了！）</p>\n<p>如果你没有64GB，128GB，或1TB（或更多）内存可用，那么分布式的多JVM部署可能是一个更好的选择。在这种场景中，你可以考虑使用Oracle HotSpot JVM的G1垃圾回收器，或者IBM JVM的平衡垃圾回收策略（Balanced Garbage Collection Policy）。下面将对这两种垃圾回收器做简单介绍。</p>\n<h2 id=\"Gargabe-First-（G1）-垃圾回收器\"><a href=\"#Gargabe-First-（G1）-垃圾回收器\" class=\"headerlink\" title=\"Gargabe-First （G1） 垃圾回收器\"></a>Gargabe-First （G1） 垃圾回收器</h2><p>G1垃圾回收器是新近才出现的垃圾回收器，是Oracle HotSpot JVM的一部分，在最近的JDK1.6版本中首次出现（译者注，该文章写于2012-07-11）。在启动Oracle JDK时附加命令行选项-XX:+UseG1GC，可以启动G1垃圾回收器。</p>\n<p>与C4类似，这款标记-清理（mark-and-sweep）垃圾回收器也可作为对低延迟有要求的应用程序的备选方案。G1算法将堆分为固定大小区域，垃圾回收会作用于其中的某些区域。在应用程序线程运行的同时，启用后台线程，并发的完成标记工作。这点与其他并发标记算法相似。</p>\n<p>G1增量方法可以使暂停时间更短，但更频繁，而这对一些力求避免长时间暂停的应用程序来说已经足够了。另一方面，正如在本系列的[Part 3][4]中介绍的，使用G1垃圾回收器需要针对应用程序的实际需求做长时间的调优，而其GC中断又是stop-the-world式的。所以对那些对低延迟有很高要求的应用程序来说，G1并不是一个好的选择。进一步说，从暂停时间总长来看，G1长于CMS（Oracle JVM中广为人知的并发垃圾回收器）。</p>\n<p>G1使用拷贝算法（在Part 3中介绍过）完成部分垃圾回收任务。这样，每次垃圾回收器后，都会产生完全可用的空闲空间。G1垃圾回收器定义了一些区域的集合作为年轻代，剩下的作为老年代。</p>\n<p>G1已经吸引了足够多的注意，引起了不小的轰动，但是它真正的挑战在于如何应对现实世界的需求。正确的调优就是其中一个挑战 —— 回忆一下，对于动态应用程序负载来说，没有永远“正确的调优”。一个问题是如何处理与分区大小相近的大对象，因为剩余的空间会成为碎片而无法使用。还有一个性能问题始终困扰着低延迟垃圾回收器，那就是垃圾回收器必须管理额外的数据结构。就我来说，使用G1的关键问题在于如何解决stop-the-world式垃圾回收器引起的暂停。Stop-the-world式的垃圾回收引起的暂停使任何垃圾回收器的能力都受制于堆大小和活动数据数量的增长，对企业级Java应用程序的伸缩性来说是一大困扰。</p>\n<h2 id=\"IBM-JVM的平衡垃圾回收策略（Balanced-Garbage-Collection-Policy）\"><a href=\"#IBM-JVM的平衡垃圾回收策略（Balanced-Garbage-Collection-Policy）\" class=\"headerlink\" title=\"IBM JVM的平衡垃圾回收策略（Balanced Garbage Collection Policy）\"></a>IBM JVM的平衡垃圾回收策略（Balanced Garbage Collection Policy）</h2><p>IBM JVM的平衡垃圾回收（Balanced Garbage Collection BGC）策略通过在启动IBM JDK时指定命令行选项-Xgcpolicy:balanced来启用。乍一看，BGC很像G1，它也是将Java堆划分成相同大小的空间，称为区间（region），执行垃圾回收时会对每个区间单独回收。为了达到最佳性能，在选择要执行垃圾回收的区间时使用了一些启发性算法。BGC中关于代的划分也与G1相似。</p>\n<p>IBM的平衡垃圾回收策略仅在64位平台得到实现，是一种NUMA架构（Non-Uniform Memory Architecture），设计之初是为了用于具有4GB以上堆的应用程序。由于拷贝算法或压缩算法的需要，BGC的部分垃圾回收工作是stop-the-world式的，并非完全并发完成。所以，归根结底，BGC也会遇到与G1和其他没有实现并发压缩选法的垃圾回收器相似的问题。</p>\n<h3 id=\"结论：回顾\"><a href=\"#结论：回顾\" class=\"headerlink\" title=\"结论：回顾\"></a>结论：回顾</h3><p>C4是基于引用跟踪的、分代式的、并发的、协作式垃圾回收算法，目前只在Azul System公司的Zing JVM得到实现。C4算法的真正价值在于：</p>\n<blockquote>\n<p>消除了重标记可能引起的重标记无限循环，也就消除了在标记阶段出现OOM错误的风险。</p>\n</blockquote>\n<blockquote>\n<p>压缩，以自动、且不断重定位的方式消除了固有限制：堆中活动数据越多，压缩所引起的暂停越长。</p>\n</blockquote>\n<blockquote>\n<p>垃圾回收不再是stop-the-world式的，大大降低垃圾回收对应用程序响应时间造成的影响。</p>\n</blockquote>\n<blockquote>\n<p>没有了清理阶段，降低了在完成GC之前就因为空闲内存不足而出现OOM错误的风险。</p>\n</blockquote>\n<blockquote>\n<p>内存可以以页为单位立即回收，使那些需要使用较多内存的Java应用程序有足够的内存可用。</p>\n</blockquote>\n<p>并发压缩是C4独一无二的优势。使应用程序线程GC线程协作运行，保证了应用程序不会因GC而被阻塞。C4将内存分配和提供足够连续空闲内存的能力完全区分开。C4使你可以为JVM实例分配尽可能大的内存，而无需为应用程序暂停而烦恼。使用得当的话，这将是JVM技术的一项革新，它可以借助于当今的多核、TB级内存的硬件优势，大大提升低延迟Java应用程序的运行速度。</p>\n<p>如果你不介意一遍又一遍的调优，以及频繁的重启的话，如果你的应用程序适用于水平部署模型的话（即部署几百个小堆JVM实例而不是几个大堆JVM实例），G1也是个不错的选择。</p>\n<p>对于<i>动态低延迟启发性自适应（dynamic low-latency heuristic adaption）</i>算法而言，BGC是一项革新，JVM研究者对此算法已经研究了几十年。该算法可以应用于较大的堆。而<i>动态自调优算法（ dynamic self-tuning algorithm）</i>的缺陷是，它无法跟上突然出现的负载高峰。那时，你将不得不面对最糟糕的场景，并根据实际情况再分配相关资源。</p>\n<p>最后，为你的应用程序选择最适合的JVM和垃圾回收器时，最重要的考虑因素是应用程序中吞吐量和暂停时间的优先级次序。你想把时间和金钱花在哪？从纯粹的技术角度说，基于我十年来对垃圾回收的经验，我一直在寻找更多关于并发压缩的革新性技术，或其他可以以较小代价完成移动对象或重定位的方法。我想影响企业级Java应用程序伸缩性的关键就在于并发性。</p>\n<p><b>JVM 性能优化系列</p>\n<p>第一篇 《<a href=\"http://www.importnew.com/1774.html\" target=\"_blank\" rel=\"noopener\">JVM性能优化， Part 1 ―― JVM简介</a> 》</p>\n<p>第二篇《<a href=\"http://www.importnew.com/2009.html\" target=\"_blank\" rel=\"noopener\">JVM性能优化， Part 2 ―― 编译器</a>》</p>\n<p>第三篇《<a href=\"http://www.importnew.com/2233.html\" target=\"_blank\" rel=\"noopener\">JVM性能优化， Part 3 —— 垃圾回收</a>》</b></p>\n<p><i>原文链接： <a href=\"https://www.infoworld.com/article/2078661/jvm-performance-optimization--part-4--c4-garbage-collection-for-low-latency-java-ap.html\" target=\"_blank\" rel=\"noopener\">javaworld</a> 翻译： <a href=\"www.importnew.com\">ImportNew.com</a> - <a href=\"http://www.importnew.com/author/caoxudong\" target=\"_blank\" rel=\"noopener\">曹旭东</a><br>译文链接： <a href=\"http://www.importnew.com/2410.html\" target=\"_blank\" rel=\"noopener\">http://www.importnew.com/2410.html</a></i></p>\n"},{"title":"JVM性能检测、故障检测工具","date":"2020-07-21T03:35:11.000Z","_content":"\n{% aplayer \"REMIND YOU(LIVE)\" \"小林未郁\" \"http://fahoud.gitee.io/hexo-dist/music/小林未郁_REMIND_YOU(LIVE).mp3\" \"https://fahoud.gitee.io/hexo-dist/music/UCvol_3.jpg\" %}\n\n# JPS：虚拟机进程状况工具\n> jps(JVM Process Status Tool)，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类(Main Class，Main()函数所在的类)名称以及这些进程的本地虚拟机唯一ID(LVMID,Local Virtual Machine Identifier).\n\nJPS主要用于查询LVMID来确定需要监控的是哪一个虚拟机进程。对于本地虚拟机进程，LVMID与操作系统的进程ID一致，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，就必须依赖jps命令显示主类的功能才能区分。\n\n> jps命令格式：jps [ options ] [ hostid ]\n\n|选项        |作用                              |\n|------------|-----------                      |\n|-q          |只输出LVMID，省略主类的名称        |\n|-m          |输出虚拟机进程启动时传递给主类main()函数的参数|\n|-l          |输出主类的全名，如果进程执行的是jar包，则输出jar路径|\n|-v          |输出虚拟机进程启动时的JVM参数| \n\n> JPS执行样例：\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/JVMjps.png\" width=\"\"></div>\n\n# jstat：虚拟机统计信息监视工具\n\n> jstat(JVM Statistics Monitoring Tool)是用于监视虚拟机各种运行状态信息的命令行工具。可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据，在没有GUI图形界面、只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的常用工具。\n\n> jstat命令格式为：jstat [ option vmid [ interval[s|ms] [count] ] ]\n\n|选项              |作用                  |\n|------            |-------               |  \n|-class            |监视类加载、卸载数量、总空间以及类装载所耗费的时间|\n|-gc               |监视Java堆状况，包括Eden区、2个Survivor区、老年代、永久代等的容量，已用空间，垃圾收集时间合计等信息|\n|-gccapacity       |监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大，最小空间|\n|-gcutil           |监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比|\n|-gccause          |与-gcutil功能一样，但额外输出导致上一次垃圾收集产生的原因|\n|-gcnew            |监视新生代垃圾收集状况|\n|-gcnewcapacity    |监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间|\n|-gcold            |监视老年代的收集状况|\n|-gcoldcapacity    |监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间|\n|-gcpermcapacity   |输出永久代使用到的最大、最小空间|\n|-compiler         |输出即时编译器编译过的方法、耗时等等信息|\n|-printcompilation |输出已经被即时编译的方法|\n\n> jstat执行样例：\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/JVMjstat.png\" width=\"\"></div>\n\n-gccause说明：\n- 新生代Eden区（E）使用了82.08%的空间，\n- S0（Survivor区）为空，S1占比41.42%，\n- 老年代（O区）使用22.7%的空间，\n- 压缩类空间和元数据空间分别占比92.9%和93.64%，\n- Minor GC次数一共发生215次，总耗时2.389s, Full GC触发4次，总耗时0.781s， 所有GC总耗时(GCT)为3.171s。\n\n> -gccause的LGCC(Last GC Cause)表示上一次GC发生原因为Allocation Failure，内存分配失败，如Eden区满导致Minor GC或老年代最大连续空间无法存入大对象导致Full GC。\n\n使用jstat工具在纯文本状态下监视虚拟机状态变化，在用户体验上不如JMC、VisualVM等可视化监视工具直接以图表形式展现的直观，但在实际生产环境中，多数服务器管理员已经习惯了在文本控制台工作，直接在控制台使用jstat命令依然是一种常用的监控方式。\n","source":"_posts/JVM性能检测、故障检测工具.md","raw":"---\ntitle: JVM性能检测、故障检测工具\ndate: 2020-07-21 11:35:11\ntags: JVM\ncategories: JVM\n---\n\n{% aplayer \"REMIND YOU(LIVE)\" \"小林未郁\" \"http://fahoud.gitee.io/hexo-dist/music/小林未郁_REMIND_YOU(LIVE).mp3\" \"https://fahoud.gitee.io/hexo-dist/music/UCvol_3.jpg\" %}\n\n# JPS：虚拟机进程状况工具\n> jps(JVM Process Status Tool)，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类(Main Class，Main()函数所在的类)名称以及这些进程的本地虚拟机唯一ID(LVMID,Local Virtual Machine Identifier).\n\nJPS主要用于查询LVMID来确定需要监控的是哪一个虚拟机进程。对于本地虚拟机进程，LVMID与操作系统的进程ID一致，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，就必须依赖jps命令显示主类的功能才能区分。\n\n> jps命令格式：jps [ options ] [ hostid ]\n\n|选项        |作用                              |\n|------------|-----------                      |\n|-q          |只输出LVMID，省略主类的名称        |\n|-m          |输出虚拟机进程启动时传递给主类main()函数的参数|\n|-l          |输出主类的全名，如果进程执行的是jar包，则输出jar路径|\n|-v          |输出虚拟机进程启动时的JVM参数| \n\n> JPS执行样例：\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/JVMjps.png\" width=\"\"></div>\n\n# jstat：虚拟机统计信息监视工具\n\n> jstat(JVM Statistics Monitoring Tool)是用于监视虚拟机各种运行状态信息的命令行工具。可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据，在没有GUI图形界面、只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的常用工具。\n\n> jstat命令格式为：jstat [ option vmid [ interval[s|ms] [count] ] ]\n\n|选项              |作用                  |\n|------            |-------               |  \n|-class            |监视类加载、卸载数量、总空间以及类装载所耗费的时间|\n|-gc               |监视Java堆状况，包括Eden区、2个Survivor区、老年代、永久代等的容量，已用空间，垃圾收集时间合计等信息|\n|-gccapacity       |监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大，最小空间|\n|-gcutil           |监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比|\n|-gccause          |与-gcutil功能一样，但额外输出导致上一次垃圾收集产生的原因|\n|-gcnew            |监视新生代垃圾收集状况|\n|-gcnewcapacity    |监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间|\n|-gcold            |监视老年代的收集状况|\n|-gcoldcapacity    |监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间|\n|-gcpermcapacity   |输出永久代使用到的最大、最小空间|\n|-compiler         |输出即时编译器编译过的方法、耗时等等信息|\n|-printcompilation |输出已经被即时编译的方法|\n\n> jstat执行样例：\n\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/JVMjstat.png\" width=\"\"></div>\n\n-gccause说明：\n- 新生代Eden区（E）使用了82.08%的空间，\n- S0（Survivor区）为空，S1占比41.42%，\n- 老年代（O区）使用22.7%的空间，\n- 压缩类空间和元数据空间分别占比92.9%和93.64%，\n- Minor GC次数一共发生215次，总耗时2.389s, Full GC触发4次，总耗时0.781s， 所有GC总耗时(GCT)为3.171s。\n\n> -gccause的LGCC(Last GC Cause)表示上一次GC发生原因为Allocation Failure，内存分配失败，如Eden区满导致Minor GC或老年代最大连续空间无法存入大对象导致Full GC。\n\n使用jstat工具在纯文本状态下监视虚拟机状态变化，在用户体验上不如JMC、VisualVM等可视化监视工具直接以图表形式展现的直观，但在实际生产环境中，多数服务器管理员已经习惯了在文本控制台工作，直接在控制台使用jstat命令依然是一种常用的监控方式。\n","slug":"JVM性能检测、故障检测工具","published":1,"updated":"2020-07-21T03:51:03.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcvei33b0006ewipb3r34543","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>\n        <div id=\"aplayer-EWFWrGmc\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\">\n            <pre class=\"aplayer-lrc-content\"></pre>\n        </div>\n        <script>\n          var ap = new APlayer({\n            element: document.getElementById(\"aplayer-EWFWrGmc\"),\n            narrow: false,\n            autoplay: false,\n            showlrc: false,\n            music: {\n              title: \"REMIND YOU(LIVE)\",\n              author: \"小林未郁\",\n              url: \"http://fahoud.gitee.io/hexo-dist/music/小林未郁_REMIND_YOU(LIVE).mp3\",\n              pic: \"https://fahoud.gitee.io/hexo-dist/music/UCvol_3.jpg\",\n              lrc: \"\"\n            }\n          });\n          window.aplayers || (window.aplayers = []);\n          window.aplayers.push(ap);\n        </script>\n\n<h1 id=\"JPS：虚拟机进程状况工具\"><a href=\"#JPS：虚拟机进程状况工具\" class=\"headerlink\" title=\"JPS：虚拟机进程状况工具\"></a>JPS：虚拟机进程状况工具</h1><blockquote>\n<p>jps(JVM Process Status Tool)，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类(Main Class，Main()函数所在的类)名称以及这些进程的本地虚拟机唯一ID(LVMID,Local Virtual Machine Identifier).</p>\n</blockquote>\n<p>JPS主要用于查询LVMID来确定需要监控的是哪一个虚拟机进程。对于本地虚拟机进程，LVMID与操作系统的进程ID一致，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，就必须依赖jps命令显示主类的功能才能区分。</p>\n<blockquote>\n<p>jps命令格式：jps [ options ] [ hostid ]</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-q</td>\n<td>只输出LVMID，省略主类的名称</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>输出虚拟机进程启动时传递给主类main()函数的参数</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>输出主类的全名，如果进程执行的是jar包，则输出jar路径</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>输出虚拟机进程启动时的JVM参数</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>JPS执行样例：</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/JVMjps.png\" width=\"\"></div>\n\n<h1 id=\"jstat：虚拟机统计信息监视工具\"><a href=\"#jstat：虚拟机统计信息监视工具\" class=\"headerlink\" title=\"jstat：虚拟机统计信息监视工具\"></a>jstat：虚拟机统计信息监视工具</h1><blockquote>\n<p>jstat(JVM Statistics Monitoring Tool)是用于监视虚拟机各种运行状态信息的命令行工具。可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据，在没有GUI图形界面、只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的常用工具。</p>\n</blockquote>\n<blockquote>\n<p>jstat命令格式为：jstat [ option vmid [ interval[s|ms] [count] ] ]</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-class</td>\n<td>监视类加载、卸载数量、总空间以及类装载所耗费的时间</td>\n</tr>\n<tr>\n<td>-gc</td>\n<td>监视Java堆状况，包括Eden区、2个Survivor区、老年代、永久代等的容量，已用空间，垃圾收集时间合计等信息</td>\n</tr>\n<tr>\n<td>-gccapacity</td>\n<td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大，最小空间</td>\n</tr>\n<tr>\n<td>-gcutil</td>\n<td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td>\n</tr>\n<tr>\n<td>-gccause</td>\n<td>与-gcutil功能一样，但额外输出导致上一次垃圾收集产生的原因</td>\n</tr>\n<tr>\n<td>-gcnew</td>\n<td>监视新生代垃圾收集状况</td>\n</tr>\n<tr>\n<td>-gcnewcapacity</td>\n<td>监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</td>\n</tr>\n<tr>\n<td>-gcold</td>\n<td>监视老年代的收集状况</td>\n</tr>\n<tr>\n<td>-gcoldcapacity</td>\n<td>监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</td>\n</tr>\n<tr>\n<td>-gcpermcapacity</td>\n<td>输出永久代使用到的最大、最小空间</td>\n</tr>\n<tr>\n<td>-compiler</td>\n<td>输出即时编译器编译过的方法、耗时等等信息</td>\n</tr>\n<tr>\n<td>-printcompilation</td>\n<td>输出已经被即时编译的方法</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>jstat执行样例：</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/JVMjstat.png\" width=\"\"></div>\n\n<p>-gccause说明：</p>\n<ul>\n<li>新生代Eden区（E）使用了82.08%的空间，</li>\n<li>S0（Survivor区）为空，S1占比41.42%，</li>\n<li>老年代（O区）使用22.7%的空间，</li>\n<li>压缩类空间和元数据空间分别占比92.9%和93.64%，</li>\n<li>Minor GC次数一共发生215次，总耗时2.389s, Full GC触发4次，总耗时0.781s， 所有GC总耗时(GCT)为3.171s。</li>\n</ul>\n<blockquote>\n<p>-gccause的LGCC(Last GC Cause)表示上一次GC发生原因为Allocation Failure，内存分配失败，如Eden区满导致Minor GC或老年代最大连续空间无法存入大对象导致Full GC。</p>\n</blockquote>\n<p>使用jstat工具在纯文本状态下监视虚拟机状态变化，在用户体验上不如JMC、VisualVM等可视化监视工具直接以图表形式展现的直观，但在实际生产环境中，多数服务器管理员已经习惯了在文本控制台工作，直接在控制台使用jstat命令依然是一种常用的监控方式。</p>\n","site":{"data":{}},"excerpt":"","more":"\n        <div id=\"aplayer-EWFWrGmc\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\">\n            <pre class=\"aplayer-lrc-content\"></pre>\n        </div>\n        <script>\n          var ap = new APlayer({\n            element: document.getElementById(\"aplayer-EWFWrGmc\"),\n            narrow: false,\n            autoplay: false,\n            showlrc: false,\n            music: {\n              title: \"REMIND YOU(LIVE)\",\n              author: \"小林未郁\",\n              url: \"http://fahoud.gitee.io/hexo-dist/music/小林未郁_REMIND_YOU(LIVE).mp3\",\n              pic: \"https://fahoud.gitee.io/hexo-dist/music/UCvol_3.jpg\",\n              lrc: \"\"\n            }\n          });\n          window.aplayers || (window.aplayers = []);\n          window.aplayers.push(ap);\n        </script>\n\n<h1 id=\"JPS：虚拟机进程状况工具\"><a href=\"#JPS：虚拟机进程状况工具\" class=\"headerlink\" title=\"JPS：虚拟机进程状况工具\"></a>JPS：虚拟机进程状况工具</h1><blockquote>\n<p>jps(JVM Process Status Tool)，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类(Main Class，Main()函数所在的类)名称以及这些进程的本地虚拟机唯一ID(LVMID,Local Virtual Machine Identifier).</p>\n</blockquote>\n<p>JPS主要用于查询LVMID来确定需要监控的是哪一个虚拟机进程。对于本地虚拟机进程，LVMID与操作系统的进程ID一致，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，就必须依赖jps命令显示主类的功能才能区分。</p>\n<blockquote>\n<p>jps命令格式：jps [ options ] [ hostid ]</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-q</td>\n<td>只输出LVMID，省略主类的名称</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>输出虚拟机进程启动时传递给主类main()函数的参数</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>输出主类的全名，如果进程执行的是jar包，则输出jar路径</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>输出虚拟机进程启动时的JVM参数</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>JPS执行样例：</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/JVMjps.png\" width=\"\"></div>\n\n<h1 id=\"jstat：虚拟机统计信息监视工具\"><a href=\"#jstat：虚拟机统计信息监视工具\" class=\"headerlink\" title=\"jstat：虚拟机统计信息监视工具\"></a>jstat：虚拟机统计信息监视工具</h1><blockquote>\n<p>jstat(JVM Statistics Monitoring Tool)是用于监视虚拟机各种运行状态信息的命令行工具。可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据，在没有GUI图形界面、只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的常用工具。</p>\n</blockquote>\n<blockquote>\n<p>jstat命令格式为：jstat [ option vmid [ interval[s|ms] [count] ] ]</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-class</td>\n<td>监视类加载、卸载数量、总空间以及类装载所耗费的时间</td>\n</tr>\n<tr>\n<td>-gc</td>\n<td>监视Java堆状况，包括Eden区、2个Survivor区、老年代、永久代等的容量，已用空间，垃圾收集时间合计等信息</td>\n</tr>\n<tr>\n<td>-gccapacity</td>\n<td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大，最小空间</td>\n</tr>\n<tr>\n<td>-gcutil</td>\n<td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td>\n</tr>\n<tr>\n<td>-gccause</td>\n<td>与-gcutil功能一样，但额外输出导致上一次垃圾收集产生的原因</td>\n</tr>\n<tr>\n<td>-gcnew</td>\n<td>监视新生代垃圾收集状况</td>\n</tr>\n<tr>\n<td>-gcnewcapacity</td>\n<td>监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</td>\n</tr>\n<tr>\n<td>-gcold</td>\n<td>监视老年代的收集状况</td>\n</tr>\n<tr>\n<td>-gcoldcapacity</td>\n<td>监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</td>\n</tr>\n<tr>\n<td>-gcpermcapacity</td>\n<td>输出永久代使用到的最大、最小空间</td>\n</tr>\n<tr>\n<td>-compiler</td>\n<td>输出即时编译器编译过的方法、耗时等等信息</td>\n</tr>\n<tr>\n<td>-printcompilation</td>\n<td>输出已经被即时编译的方法</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>jstat执行样例：</p>\n</blockquote>\n<div align=center>\n<img src=\"http://fahoud.gitee.io/hexo-dist/jvm/JVMjstat.png\" width=\"\"></div>\n\n<p>-gccause说明：</p>\n<ul>\n<li>新生代Eden区（E）使用了82.08%的空间，</li>\n<li>S0（Survivor区）为空，S1占比41.42%，</li>\n<li>老年代（O区）使用22.7%的空间，</li>\n<li>压缩类空间和元数据空间分别占比92.9%和93.64%，</li>\n<li>Minor GC次数一共发生215次，总耗时2.389s, Full GC触发4次，总耗时0.781s， 所有GC总耗时(GCT)为3.171s。</li>\n</ul>\n<blockquote>\n<p>-gccause的LGCC(Last GC Cause)表示上一次GC发生原因为Allocation Failure，内存分配失败，如Eden区满导致Minor GC或老年代最大连续空间无法存入大对象导致Full GC。</p>\n</blockquote>\n<p>使用jstat工具在纯文本状态下监视虚拟机状态变化，在用户体验上不如JMC、VisualVM等可视化监视工具直接以图表形式展现的直观，但在实际生产环境中，多数服务器管理员已经习惯了在文本控制台工作，直接在控制台使用jstat命令依然是一种常用的监控方式。</p>\n"},{"title":"git pull之后merging冲突解决","date":"2020-07-12T06:15:29.000Z","_content":"# 解决merging冲突\n\n{% aplayer \"BECAUSE\" \"小林未郁\" \"小林未郁_BECAUSE.mp3\" \"https://fahoud.gitee.io/hexo-dist/music/mika_Because.jpg\" %}\n\n## 一、出现merging冲突的原因\n> git远程上存在一个本地不存在的git 分支，就是本地远程代码不同步\n\n## 二、解决方式:\n\n### 方法一：\n- git pull 出现冲突后可以暂存本地修改git stash ,然后git pull 更新代码，\n- git stash list 可查看暂存记录列表，释放本地暂存 \n- git stash apply stash@{0} ,出现冲突文件，找到并解决，\n- 然后可以提交git add . 加入索引库，然后本地提交git commit -m '注释' 最后git push到远程\n\n### 方法二：\n- 1.git pull  更新代码，发现:\n> error: Your local changes to the following files would be overwritten by merge:pom.xml\nPlease commit your changes or stash them before you merge.\n- 这说明你的pom.xml与远程有冲突，你需要先提交本地的修改然后更新。\n\n- 2.git add pom.xml   git commit -m '冲突解决'    提交本地的pom.xml文件，不进行推送远程\n\n- 3.git pull   更新代码\n> Auto-merging pom.xml\n  CONFLICT (content): Merge conflict in pom.xml\n  Automatic merge failed; fix conflicts and then commit the result.\n- 更新后你的本地分支上会出现 (develop|MERGING)类似这种标志\n\n- 4.找到你本地的pom.xml文件，并打开\n> 你会在文件中发现<<<<<<< HEAD ，=======  ，>>>>>>> ae9a0f6b7e42fda2ce9b14a21a7a03cfc5344d61 这种标记，<<<<<<< HEAD和=======中间的是你自己的代码，  =======  和>>>>>>>中间的是其他人修改的代码 自己确定保留那一部分代码，最后删除<<<<<<< HEAD ，=======  ，>>>>>>>这种标志\n\n- 5.git add pom.xml    git commit -m '冲突解决结束'   再次将本地的pom.xml文件提交\n\n- 6.git push   将解决冲突后的文件推送到远程\n","source":"_posts/git-pull之后merging冲突解决.md","raw":"---\ntitle: git pull之后merging冲突解决\ndate: 2020-07-12 14:15:29\ntags: Git\ncategories: Git\n---\n# 解决merging冲突\n\n{% aplayer \"BECAUSE\" \"小林未郁\" \"小林未郁_BECAUSE.mp3\" \"https://fahoud.gitee.io/hexo-dist/music/mika_Because.jpg\" %}\n\n## 一、出现merging冲突的原因\n> git远程上存在一个本地不存在的git 分支，就是本地远程代码不同步\n\n## 二、解决方式:\n\n### 方法一：\n- git pull 出现冲突后可以暂存本地修改git stash ,然后git pull 更新代码，\n- git stash list 可查看暂存记录列表，释放本地暂存 \n- git stash apply stash@{0} ,出现冲突文件，找到并解决，\n- 然后可以提交git add . 加入索引库，然后本地提交git commit -m '注释' 最后git push到远程\n\n### 方法二：\n- 1.git pull  更新代码，发现:\n> error: Your local changes to the following files would be overwritten by merge:pom.xml\nPlease commit your changes or stash them before you merge.\n- 这说明你的pom.xml与远程有冲突，你需要先提交本地的修改然后更新。\n\n- 2.git add pom.xml   git commit -m '冲突解决'    提交本地的pom.xml文件，不进行推送远程\n\n- 3.git pull   更新代码\n> Auto-merging pom.xml\n  CONFLICT (content): Merge conflict in pom.xml\n  Automatic merge failed; fix conflicts and then commit the result.\n- 更新后你的本地分支上会出现 (develop|MERGING)类似这种标志\n\n- 4.找到你本地的pom.xml文件，并打开\n> 你会在文件中发现<<<<<<< HEAD ，=======  ，>>>>>>> ae9a0f6b7e42fda2ce9b14a21a7a03cfc5344d61 这种标记，<<<<<<< HEAD和=======中间的是你自己的代码，  =======  和>>>>>>>中间的是其他人修改的代码 自己确定保留那一部分代码，最后删除<<<<<<< HEAD ，=======  ，>>>>>>>这种标志\n\n- 5.git add pom.xml    git commit -m '冲突解决结束'   再次将本地的pom.xml文件提交\n\n- 6.git push   将解决冲突后的文件推送到远程\n","slug":"git-pull之后merging冲突解决","published":1,"updated":"2020-07-18T04:04:45.704Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcvei33e0008ewip42xn9pjy","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"解决merging冲突\"><a href=\"#解决merging冲突\" class=\"headerlink\" title=\"解决merging冲突\"></a>解决merging冲突</h1>\n        <div id=\"aplayer-FvHrBciW\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\">\n            <pre class=\"aplayer-lrc-content\"></pre>\n        </div>\n        <script>\n          var ap = new APlayer({\n            element: document.getElementById(\"aplayer-FvHrBciW\"),\n            narrow: false,\n            autoplay: false,\n            showlrc: false,\n            music: {\n              title: \"BECAUSE\",\n              author: \"小林未郁\",\n              url: \"小林未郁_BECAUSE.mp3\",\n              pic: \"https://fahoud.gitee.io/hexo-dist/music/mika_Because.jpg\",\n              lrc: \"\"\n            }\n          });\n          window.aplayers || (window.aplayers = []);\n          window.aplayers.push(ap);\n        </script>\n\n<h2 id=\"一、出现merging冲突的原因\"><a href=\"#一、出现merging冲突的原因\" class=\"headerlink\" title=\"一、出现merging冲突的原因\"></a>一、出现merging冲突的原因</h2><blockquote>\n<p>git远程上存在一个本地不存在的git 分支，就是本地远程代码不同步</p>\n</blockquote>\n<h2 id=\"二、解决方式\"><a href=\"#二、解决方式\" class=\"headerlink\" title=\"二、解决方式:\"></a>二、解决方式:</h2><h3 id=\"方法一：\"><a href=\"#方法一：\" class=\"headerlink\" title=\"方法一：\"></a>方法一：</h3><ul>\n<li>git pull 出现冲突后可以暂存本地修改git stash ,然后git pull 更新代码，</li>\n<li>git stash list 可查看暂存记录列表，释放本地暂存 </li>\n<li>git stash apply stash@{0} ,出现冲突文件，找到并解决，</li>\n<li>然后可以提交git add . 加入索引库，然后本地提交git commit -m ‘注释’ 最后git push到远程</li>\n</ul>\n<h3 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h3><ul>\n<li><p>1.git pull  更新代码，发现:</p>\n<blockquote>\n<p>error: Your local changes to the following files would be overwritten by merge:pom.xml<br>Please commit your changes or stash them before you merge.</p>\n</blockquote>\n</li>\n<li><p>这说明你的pom.xml与远程有冲突，你需要先提交本地的修改然后更新。</p>\n</li>\n<li><p>2.git add pom.xml   git commit -m ‘冲突解决’    提交本地的pom.xml文件，不进行推送远程</p>\n</li>\n<li><p>3.git pull   更新代码</p>\n<blockquote>\n<p>Auto-merging pom.xml<br>CONFLICT (content): Merge conflict in pom.xml<br>Automatic merge failed; fix conflicts and then commit the result.</p>\n</blockquote>\n</li>\n<li><p>更新后你的本地分支上会出现 (develop|MERGING)类似这种标志</p>\n</li>\n<li><p>4.找到你本地的pom.xml文件，并打开</p>\n<blockquote>\n<p>你会在文件中发现&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ，=======  ，&gt;&gt;&gt;&gt;&gt;&gt;&gt; ae9a0f6b7e42fda2ce9b14a21a7a03cfc5344d61 这种标记，&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD和=======中间的是你自己的代码，  =======  和&gt;&gt;&gt;&gt;&gt;&gt;&gt;中间的是其他人修改的代码 自己确定保留那一部分代码，最后删除&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ，=======  ，&gt;&gt;&gt;&gt;&gt;&gt;&gt;这种标志</p>\n</blockquote>\n</li>\n<li><p>5.git add pom.xml    git commit -m ‘冲突解决结束’   再次将本地的pom.xml文件提交</p>\n</li>\n<li><p>6.git push   将解决冲突后的文件推送到远程</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"解决merging冲突\"><a href=\"#解决merging冲突\" class=\"headerlink\" title=\"解决merging冲突\"></a>解决merging冲突</h1>\n        <div id=\"aplayer-FvHrBciW\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\">\n            <pre class=\"aplayer-lrc-content\"></pre>\n        </div>\n        <script>\n          var ap = new APlayer({\n            element: document.getElementById(\"aplayer-FvHrBciW\"),\n            narrow: false,\n            autoplay: false,\n            showlrc: false,\n            music: {\n              title: \"BECAUSE\",\n              author: \"小林未郁\",\n              url: \"小林未郁_BECAUSE.mp3\",\n              pic: \"https://fahoud.gitee.io/hexo-dist/music/mika_Because.jpg\",\n              lrc: \"\"\n            }\n          });\n          window.aplayers || (window.aplayers = []);\n          window.aplayers.push(ap);\n        </script>\n\n<h2 id=\"一、出现merging冲突的原因\"><a href=\"#一、出现merging冲突的原因\" class=\"headerlink\" title=\"一、出现merging冲突的原因\"></a>一、出现merging冲突的原因</h2><blockquote>\n<p>git远程上存在一个本地不存在的git 分支，就是本地远程代码不同步</p>\n</blockquote>\n<h2 id=\"二、解决方式\"><a href=\"#二、解决方式\" class=\"headerlink\" title=\"二、解决方式:\"></a>二、解决方式:</h2><h3 id=\"方法一：\"><a href=\"#方法一：\" class=\"headerlink\" title=\"方法一：\"></a>方法一：</h3><ul>\n<li>git pull 出现冲突后可以暂存本地修改git stash ,然后git pull 更新代码，</li>\n<li>git stash list 可查看暂存记录列表，释放本地暂存 </li>\n<li>git stash apply stash@{0} ,出现冲突文件，找到并解决，</li>\n<li>然后可以提交git add . 加入索引库，然后本地提交git commit -m ‘注释’ 最后git push到远程</li>\n</ul>\n<h3 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h3><ul>\n<li><p>1.git pull  更新代码，发现:</p>\n<blockquote>\n<p>error: Your local changes to the following files would be overwritten by merge:pom.xml<br>Please commit your changes or stash them before you merge.</p>\n</blockquote>\n</li>\n<li><p>这说明你的pom.xml与远程有冲突，你需要先提交本地的修改然后更新。</p>\n</li>\n<li><p>2.git add pom.xml   git commit -m ‘冲突解决’    提交本地的pom.xml文件，不进行推送远程</p>\n</li>\n<li><p>3.git pull   更新代码</p>\n<blockquote>\n<p>Auto-merging pom.xml<br>CONFLICT (content): Merge conflict in pom.xml<br>Automatic merge failed; fix conflicts and then commit the result.</p>\n</blockquote>\n</li>\n<li><p>更新后你的本地分支上会出现 (develop|MERGING)类似这种标志</p>\n</li>\n<li><p>4.找到你本地的pom.xml文件，并打开</p>\n<blockquote>\n<p>你会在文件中发现&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ，=======  ，&gt;&gt;&gt;&gt;&gt;&gt;&gt; ae9a0f6b7e42fda2ce9b14a21a7a03cfc5344d61 这种标记，&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD和=======中间的是你自己的代码，  =======  和&gt;&gt;&gt;&gt;&gt;&gt;&gt;中间的是其他人修改的代码 自己确定保留那一部分代码，最后删除&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ，=======  ，&gt;&gt;&gt;&gt;&gt;&gt;&gt;这种标志</p>\n</blockquote>\n</li>\n<li><p>5.git add pom.xml    git commit -m ‘冲突解决结束’   再次将本地的pom.xml文件提交</p>\n</li>\n<li><p>6.git push   将解决冲突后的文件推送到远程</p>\n</li>\n</ul>\n"},{"title":"git博客分支管理","date":"2020-07-13T02:47:40.000Z","_content":"\n\n# git hexo部署到github的源码管理\n\n\n## master用于部署hexo\n> 每次写完文档后，不希望把所有数据都保存到服务器中，希望把源码和数据都保存到github中。\n> 因为github规定了部署博客必需为master分支，所以用master部署hexo，用dev存储整个hexo文件夹\n\n> 实现hexo d先执行以下命令安装插件\n```bash\n$ npm install hexo-deployer-git --save \n```\n\n\n> _config.yml文件中部署配置\n```bash\ndeploy:\n  type: git\n  repo:  \n    gitee: https://gitee.com/Fahoud/Fahoud.git\n    github: https://github.com/Fahoud/fahoud.github.io.git\n  branch: master\n```\n\n> 更改文档内容或者主题设置后部署到github或者码云\n```bash\n $ hexo claen\n $ hexo g\n $ hexo d\n```\n\n## dev分支存储源码\n\n> 本地只有一条分支，为master\n\n> 把整个hexo文件夹推送到github或者码云\n```bash\n$ git add .     #add所有更改\n$ git commit -m 'Update xxx'   #commit\n$ git push github master:dev    #推上github的dev分支\n$ \n$ git add . \n$ git commit -m 'Update xxx'\n$ git push gitee master:hexo   #推上gitee的hexo分支\n```\n","source":"_posts/git博客分支管理.md","raw":"---\ntitle: git博客分支管理\ndate: 2020-07-13 10:47:40\ntags: Git\ncategories: Git\n---\n\n\n# git hexo部署到github的源码管理\n\n\n## master用于部署hexo\n> 每次写完文档后，不希望把所有数据都保存到服务器中，希望把源码和数据都保存到github中。\n> 因为github规定了部署博客必需为master分支，所以用master部署hexo，用dev存储整个hexo文件夹\n\n> 实现hexo d先执行以下命令安装插件\n```bash\n$ npm install hexo-deployer-git --save \n```\n\n\n> _config.yml文件中部署配置\n```bash\ndeploy:\n  type: git\n  repo:  \n    gitee: https://gitee.com/Fahoud/Fahoud.git\n    github: https://github.com/Fahoud/fahoud.github.io.git\n  branch: master\n```\n\n> 更改文档内容或者主题设置后部署到github或者码云\n```bash\n $ hexo claen\n $ hexo g\n $ hexo d\n```\n\n## dev分支存储源码\n\n> 本地只有一条分支，为master\n\n> 把整个hexo文件夹推送到github或者码云\n```bash\n$ git add .     #add所有更改\n$ git commit -m 'Update xxx'   #commit\n$ git push github master:dev    #推上github的dev分支\n$ \n$ git add . \n$ git commit -m 'Update xxx'\n$ git push gitee master:hexo   #推上gitee的hexo分支\n```\n","slug":"git博客分支管理","published":1,"updated":"2020-07-18T04:05:13.391Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcvei33g0009ewipgqkodala","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"git-hexo部署到github的源码管理\"><a href=\"#git-hexo部署到github的源码管理\" class=\"headerlink\" title=\"git hexo部署到github的源码管理\"></a>git hexo部署到github的源码管理</h1><h2 id=\"master用于部署hexo\"><a href=\"#master用于部署hexo\" class=\"headerlink\" title=\"master用于部署hexo\"></a>master用于部署hexo</h2><blockquote>\n<p>每次写完文档后，不希望把所有数据都保存到服务器中，希望把源码和数据都保存到github中。<br>因为github规定了部署博客必需为master分支，所以用master部署hexo，用dev存储整个hexo文件夹</p>\n</blockquote>\n<blockquote>\n<p>实现hexo d先执行以下命令安装插件</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>_config.yml文件中部署配置</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo:  </span><br><span class=\"line\">    gitee: https://gitee.com/Fahoud/Fahoud.git</span><br><span class=\"line\">    github: https://github.com/Fahoud/fahoud.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>更改文档内容或者主题设置后部署到github或者码云</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo claen</span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"dev分支存储源码\"><a href=\"#dev分支存储源码\" class=\"headerlink\" title=\"dev分支存储源码\"></a>dev分支存储源码</h2><blockquote>\n<p>本地只有一条分支，为master</p>\n</blockquote>\n<blockquote>\n<p>把整个hexo文件夹推送到github或者码云</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .     <span class=\"comment\">#add所有更改</span></span><br><span class=\"line\">$ git commit -m <span class=\"string\">'Update xxx'</span>   <span class=\"comment\">#commit</span></span><br><span class=\"line\">$ git push github master:dev    <span class=\"comment\">#推上github的dev分支</span></span><br><span class=\"line\">$ </span><br><span class=\"line\">$ git add . </span><br><span class=\"line\">$ git commit -m <span class=\"string\">'Update xxx'</span></span><br><span class=\"line\">$ git push gitee master:hexo   <span class=\"comment\">#推上gitee的hexo分支</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"git-hexo部署到github的源码管理\"><a href=\"#git-hexo部署到github的源码管理\" class=\"headerlink\" title=\"git hexo部署到github的源码管理\"></a>git hexo部署到github的源码管理</h1><h2 id=\"master用于部署hexo\"><a href=\"#master用于部署hexo\" class=\"headerlink\" title=\"master用于部署hexo\"></a>master用于部署hexo</h2><blockquote>\n<p>每次写完文档后，不希望把所有数据都保存到服务器中，希望把源码和数据都保存到github中。<br>因为github规定了部署博客必需为master分支，所以用master部署hexo，用dev存储整个hexo文件夹</p>\n</blockquote>\n<blockquote>\n<p>实现hexo d先执行以下命令安装插件</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>_config.yml文件中部署配置</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo:  </span><br><span class=\"line\">    gitee: https://gitee.com/Fahoud/Fahoud.git</span><br><span class=\"line\">    github: https://github.com/Fahoud/fahoud.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>更改文档内容或者主题设置后部署到github或者码云</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo claen</span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"dev分支存储源码\"><a href=\"#dev分支存储源码\" class=\"headerlink\" title=\"dev分支存储源码\"></a>dev分支存储源码</h2><blockquote>\n<p>本地只有一条分支，为master</p>\n</blockquote>\n<blockquote>\n<p>把整个hexo文件夹推送到github或者码云</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .     <span class=\"comment\">#add所有更改</span></span><br><span class=\"line\">$ git commit -m <span class=\"string\">'Update xxx'</span>   <span class=\"comment\">#commit</span></span><br><span class=\"line\">$ git push github master:dev    <span class=\"comment\">#推上github的dev分支</span></span><br><span class=\"line\">$ </span><br><span class=\"line\">$ git add . </span><br><span class=\"line\">$ git commit -m <span class=\"string\">'Update xxx'</span></span><br><span class=\"line\">$ git push gitee master:hexo   <span class=\"comment\">#推上gitee的hexo分支</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2020-07-12T01:39:19.900Z","updated":"2020-07-12T01:39:19.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcvei33k000dewip3wft3i4z","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"我的第一篇文章","date":"2020-07-12T01:49:00.000Z","_content":"\n\n# 第一次搞博客\nBGM：小林未郁-BECAUSE\n\n\n","source":"_posts/我的第一篇文章.md","raw":"---\ntitle: 我的第一篇文章\ndate: 2020-07-12 09:49:00\ntags:\n---\n\n\n# 第一次搞博客\nBGM：小林未郁-BECAUSE\n\n\n","slug":"我的第一篇文章","published":1,"updated":"2020-07-12T06:34:33.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcvei33m000eewiphlat2ox6","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"第一次搞博客\"><a href=\"#第一次搞博客\" class=\"headerlink\" title=\"第一次搞博客\"></a>第一次搞博客</h1><p>BGM：小林未郁-BECAUSE</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第一次搞博客\"><a href=\"#第一次搞博客\" class=\"headerlink\" title=\"第一次搞博客\"></a>第一次搞博客</h1><p>BGM：小林未郁-BECAUSE</p>\n"}],"PostAsset":[{"_id":"source/_posts/git-pull之后merging冲突解决/小林未郁_BECAUSE.jpg","post":"ckcvei33e0008ewip42xn9pjy","slug":"小林未郁_BECAUSE.jpg","modified":1,"renderable":1},{"_id":"source/_posts/git-pull之后merging冲突解决/小林未郁_BECAUSE.mp3","slug":"小林未郁_BECAUSE.mp3","post":"ckcvei33e0008ewip42xn9pjy","modified":1,"renderable":0}],"PostCategory":[{"post_id":"ckcvei32u0000ewip0huhdk2z","category_id":"ckcvei3360004ewipagqs5qt4","_id":"ckcvei33n000gewipagl9b5kl"},{"post_id":"ckcvei3320002ewip43o60fdn","category_id":"ckcvei3360004ewipagqs5qt4","_id":"ckcvei33p000kewip9dv3akis"},{"post_id":"ckcvei33b0006ewipb3r34543","category_id":"ckcvei3360004ewipagqs5qt4","_id":"ckcvei33q000newipc8uo8hgv"},{"post_id":"ckcvei33e0008ewip42xn9pjy","category_id":"ckcvei33p000jewip6tcj6mk8","_id":"ckcvei33r000rewip8mzt7bqa"},{"post_id":"ckcvei33g0009ewipgqkodala","category_id":"ckcvei33p000jewip6tcj6mk8","_id":"ckcvei33s000tewip36gf4ahg"}],"PostTag":[{"post_id":"ckcvei32u0000ewip0huhdk2z","tag_id":"ckcvei33a0005ewipcg29eojs","_id":"ckcvei33j000cewip6p950g0l"},{"post_id":"ckcvei3320002ewip43o60fdn","tag_id":"ckcvei33a0005ewipcg29eojs","_id":"ckcvei33o000iewip5vg2fby6"},{"post_id":"ckcvei33b0006ewipb3r34543","tag_id":"ckcvei33a0005ewipcg29eojs","_id":"ckcvei33q000mewipccbk2590"},{"post_id":"ckcvei33e0008ewip42xn9pjy","tag_id":"ckcvei33p000lewipc8b0bhsb","_id":"ckcvei33r000qewip05m527ho"},{"post_id":"ckcvei33g0009ewipgqkodala","tag_id":"ckcvei33p000lewipc8b0bhsb","_id":"ckcvei33s000sewip00vw2csf"}],"Tag":[{"name":"JVM","_id":"ckcvei33a0005ewipcg29eojs"},{"name":"Git","_id":"ckcvei33p000lewipc8b0bhsb"}]}}